{"version":3,"file":"nextcloud-client.es.min.js","sources":["../source/errors.ts","../source/webdav.wrapper.ts","../source/webdav.utils.ts","../source/webdav.ts","../source/common.ts","../source/ocs/types.ts","../source/ocs/helper.ts","../source/requestWrapper.ts","../source/ocs/ocs-connection.ts","../source/ocs/user.ts","../source/ocs/group.ts","../source/ocs/share.ts","../source/ocs/groupfolders.ts","../source/ocs/ocs.ts","../source/ocs/activity.ts","../source/types.ts","../source/helper.ts","../source/client.ts"],"sourcesContent":["/**\n * Return a constructor for a new error type.\n *\n * @function createErrorType\n *\n * @param initialize A function that gets passed the constructed error and the passed message and\n *                              runs during the construction of new instances.\n * @param ErrorClass An error class you wish to subclass. Defaults to Error.\n * @param prototype Additional properties and methods for the new error type.\n *\n * @return The constructor for the new error type.\n */\nfunction createErrorType<\n  TInitialize extends (error: Error, ...args: any[]) => void,\n  TErrorClass extends new (...args: any[]) => Error = ErrorConstructor,\n  TPrototype extends object = object\n>(\n  initialize: TInitialize,\n  ErrorClass?: TErrorClass,\n  prototype?: TPrototype\n) {\n  ErrorClass ??= Error as any;\n\n  let Constructor = function (...data: any[]) {\n    let error = Object.create(Constructor.prototype);\n\n    error.stack = (new Error).stack;\n\n    if (initialize) {\n      initialize(error, ...data);\n    }\n\n    return error;\n  } ;\n\n  Constructor.prototype = Object.create(ErrorClass!.prototype);\n\n  if (prototype) {\n    Object.assign(Constructor.prototype, prototype);\n  }\n\n  return Constructor as unknown as (\n    TInitialize extends undefined\n      ? (new (message: string) => Error)\n      : (\n        TInitialize extends (error: Error, ...args: infer TArgs) => void\n          ? (new (...args: TArgs) => Error)\n          : never\n      )\n  );\n}\n\nexport const NextCloudException = createErrorType(\n  function nextCloudError(error, message: string, subError?: Error) {\n    error.message = message;\n    if (subError) {\n      error.message += `: ${subError.message}`;\n      error.stack = subError.stack;\n    }\n  },\n);\n\nexport const NextCloudServerException = createErrorType(\n  function nextCloudError(error, message: string, subError?: Error) {\n    error.message = message;\n    if (subError) {\n      error.message += `: ${subError.message}`;\n      error.stack = subError.stack;\n    }\n  },\n\n  NextCloudException\n);\n\nexport const NextCloudClientException = createErrorType(\n  function nextCloudError(error, message: string, subError?: Error) {\n    error.message = message;\n    if (subError) {\n      error.message += `: ${subError.message}`;\n      error.stack = subError.stack;\n    }\n  },\n\n  NextCloudException\n);\n\nexport const ForbiddenError = createErrorType(\n  function forbiddenErrorConstructor(error, path: string) {\n    error.message = `Access to ${path} was denied`;\n  },\n\n  NextCloudServerException\n);\n\nexport const NotFoundError = createErrorType(\n  function notFoundErrorConstructor(error, path: string) {\n    error.message = `${path} not found!`;\n  },\n\n  NextCloudServerException\n);\n\nexport const NotReadyError = createErrorType(\n  function notReadyErrorConstructor(error) {\n    error.message = 'The Nextcloud instance is initializing…';\n  },\n\n  NextCloudServerException\n);\n\nexport const UnreachableError = createErrorType(\n  function notReadyErrorConstructor(error) {\n    error.message = 'The Nextcloud instance is unreachable…';\n  },\n\n  NextCloudServerException\n);\n\nexport const IncorrectPathTypeError = createErrorType(\n  function incorrectPathTypeErrorConstructor(error, options: { path: string, type: string }) {\n    const {path, type} = options;\n    error.message = `The path '${path}' is not a ${type}`;\n  },\n\n  NextCloudServerException\n);\n\nexport const ConflictError = createErrorType(\n  function conflictErrorConstructor(error, path: string) {\n    error.message = `Conflict on ${path}`;\n  },\n\n  NextCloudServerException\n);\n\nexport const OcsError = createErrorType(\n  function ocsErrorConstructor(error, options: { message: string, identifier?: string | number, reason: string, statusCode?: string | number }) {\n    const {message, identifier, reason, statusCode} = options;\n\n    const id = (identifier ? ` '${identifier}'` : '');\n    error.name = 'OcsError';\n    error.message = `${message}${id}: ${reason}`;\n    if (statusCode) {\n      (error as any).statusCode = statusCode;\n    }\n  },\n\n  NextCloudServerException\n);\n\nexport const BadArgumentError = createErrorType(\n  function badArgumentErrorConstructor(error, message: string) {\n    error.message = message;\n  },\n\n  NextCloudClientException\n);\n","import type { WebDAVClient, WebDAVClientError } from \"webdav\";\nimport { NotFoundError, ForbiddenError, ConflictError, NextCloudServerException } from './errors';\n\n// prefer whitelist over blacklist (or looping over all functions)\n//   - less likely to break\nconst WRAPPED_FUNCTIONS: [\n  /**\n   * The name of the function to wrap.\n   */\n  string,\n\n  /**\n   * The position of the path argument in the original function.\n   * @note -1 means no path argument.\n   */\n  number\n][] = [\n  ['copyFile', 0],\n  ['createDirectory', 0],\n  ['createReadStream', 0],\n  ['createWriteStream', 0],\n  ['customRequest', 0],\n  ['deleteFile', 0],\n  ['exists', 0],\n  ['getDirectoryContents', 0],\n  ['getFileContents', 0],\n  ['getFileDownloadLink', 0],\n  ['getFileUploadLink', 0],\n  ['getHeaders', -1], // No path argument for getHeaders\n  ['getQuota', -1], // No options argument for getQuota\n  ['lock', 0],\n  ['moveFile', 0],\n  ['putFileContents', 0],\n  ['setHeaders', -1], // No path argument for setHeaders\n  ['stat', 0],\n  ['unlock', 0]\n];\n\n/**\n * Wraps a WebDAVClient to throw NextcloudErrors instead of WebDAVClientError.\n * @param client The client to wrap.\n * @returns The wrapped client.\n *\n * @note This function mutates the client.\n * @note This function is idempotent.\n */\nexport function wrapClient(client: WebDAVClient): WebDAVClient {\n  if (client['__ns_wrapped_client__']) {\n    return client;\n  }\n  client['__ns_wrapped_client__'] = true;\n\n  WRAPPED_FUNCTIONS.forEach(([fnName, pathPosition]) => {\n    const originalFn = client[fnName];\n    client[fnName] = async (...args: any[]) => {\n      try {\n        return await originalFn.apply(client, args);\n      } catch (error) {\n        throw wrapError(error, pathPosition === -1 ? undefined : args[pathPosition]);\n      }\n    };\n  });\n\n  return client;\n}\n\n/**\n * Wraps a WebDAVClientError to throw NextcloudErrors instead.\n * @param error The error to wrap.\n * @param path The path of the operation that failed.\n * @returns The wrapped error.\n */\nexport function wrapError(error: Error, path?: string): Error {\n  if (!isWebDavError(error)) {\n    return error;\n  }\n\n  if (isNotFoundError(error)) {\n    return new NotFoundError(path)\n  }\n\n  if (isForbiddenError(error)) {\n    return new ForbiddenError(path);\n  }\n\n  if (isConflictError(error)) {\n    return new ConflictError(path);\n  }\n\n  return new NextCloudServerException('A WebDav Error occured', error);\n}\n\n/**\n * Checks if the given error is a WebDAVClientError.\n * @param error The error to check.\n * @returns True if the error is a WebDAVClientError.\n */\nfunction isWebDavError(error: any): error is WebDAVClientError {\n  return error && (error.response || error.status);\n}\n\n/**\n * Checks if the given error is a NotFoundError.\n * @param error The error to check.\n * @returns True if the error is a NotFoundError.\n */\nfunction isNotFoundError(error: WebDAVClientError): error is { status: 404 } & WebDAVClientError {\n  return error.status === 404;\n}\n\n/**\n * Checks if the given error is a ForbiddenError.\n * @param error The error to check.\n * @returns True if the error is a ForbiddenError.\n */\nfunction isForbiddenError(error: WebDAVClientError): error is { status: 403 } & WebDAVClientError {\n  return error.status === 403;\n}\n\n/**\n * Checks if the given error is a ConflictError.\n * @param error The error to check.\n * @returns True if the error is a ConflictError.\n */\nfunction isConflictError(error: WebDAVClientError): error is { status: 409 } & WebDAVClientError {\n  return error.status === 409;\n}\n\n","import { BadArgumentError } from './errors'\n\nexport type NAMESPACE = {\n  full: string;\n  short: string;\n  elements: readonly string[];\n}\n\nexport type ShortCodes = typeof NAMESPACES[number][\"short\"];\nexport type ShortCodeToNamespace = {\n  [key in ShortCodes]: typeof NAMESPACES[number] & { short: key };\n}\n\nexport type ShortCodeElements<TShortCode extends ShortCodes> = \"elements\" extends keyof ShortCodeToNamespace[TShortCode]\n  ? ShortCodeToNamespace[TShortCode]['elements']\n  : never;\n\nexport type DetailProperty<\n  TShortCode extends ShortCodes,\n  TElement extends ShortCodeElements<TShortCode> | string\n> = {\n  namespaceShort: TShortCode,\n  namespace: TElement,\n  element: string,\n  default?: any\n}\n\nexport type ExtractDetailProperties<TDetails extends DetailProperty<any,any>[]> = TDetails[number]['namespace']\n\n/**\n * All known namespaces and their elements that are used in the Nextcloud WebDAV API.\n * @see https://docs.nextcloud.com/server/latest/developer_manual/client_apis/WebDAV/basic.html#supported-properties\n */\nconst NAMESPACES = [\n  {\n    short: \"d\",\n    full: \"DAV:\",\n    elements: [\n      \"creationdate\",\n      \"getlastmodified\",\n      \"getetag\",\n      \"getcontenttype\",\n      \"resourcetype\",\n      \"getcontentlength\",\n      \"getcontentlanguage\",\n      \"displayname\",\n      \"lockdiscovery\",\n      \"supportedlock\",\n    ]\n  },\n  {\n    short: \"oc\",\n    full: \"http://owncloud.org/ns\",\n    elements: [\n      \"id\",\n      \"fileid\",\n      \"downloadURL\",\n      \"permissions\",\n      \"size\",\n      \"quota-used-bytes\",\n      \"quota-available-bytes\",\n      \"tags\",\n      \"favorite\",\n      \"comments-href\",\n      \"comments-count\",\n      \"comments-unread\",\n      \"owner-id\",\n      \"owner-display-name\",\n      \"share-types\",\n      \"checksums\",\n      \"has-preview\",\n      \"rich-workspace-file\",\n      \"rich-workspace\",\n    ]\n  },\n  {\n    short: \"nc\",\n    full: \"http://nextcloud.org/ns\",\n    elements: [\n      \"creation_time\",\n      \"mount-type\",\n      \"is-encrypted\",\n      \"share-attributes\",\n      \"sharees\",\n      \"share-permissions\",\n      \"acl-enabled\",\n      \"acl-can-manage\",\n      \"acl-list\",\n      \"inherited-acl-list\",\n      \"group-folder-id\",\n      \"lock\",\n      \"lock-owner-type\",\n      \"lock-owner\",\n      \"lock-owner-displayname\",\n      \"lock-owner-editor\",\n      \"lock-time\",\n      \"lock-timeout\",\n      \"lock-token\",\n      \"contained-folder-count\",\n      \"contained-file-count\",\n      \"data-fingerprint\",\n      \"upload_time\",\n      \"note\",\n    ]\n  },\n  {\n    short: \"ocs\",\n    full: \"http://open-collaboration-services.org/ns\",\n    elements: [\n      \"share-permissions\",\n    ]\n  },\n  {\n    short: \"ocm\",\n    full: \"http://open-cloud-mesh.org/ns\",\n    elements: [\n      \"share-permissions\",\n    ]\n  },\n] as const;\n\nconst SHORT_CODE_TO_NAMESPACE: ShortCodeToNamespace = NAMESPACES\n  .reduce((acc, namespace) => {\n    acc[namespace.short] = namespace;\n    return acc;\n  }, {} as any);\n\n  /**\n   * Creates a detail property for use with the various WebDAV methods.\n   * @param namespace The namespace short code (e.g. `oc`)\n   * @param element The element name (e.g. `fileid`)\n   * @param defaultValue The default value to return if the property is not found\n   *\n   * @example\n   * const fileidProperty = createDetailProperty('oc', 'fileid');\n   *\n   * const details = await client.getPathInfo('/path/to/file', {\n   *  details: true,\n   *  properties: [\n   *    fileidProperty\n   *  ]\n   * });\n   */\nexport function createDetailProperty<\n  TShortCode extends ShortCodes,\n  TElement extends ShortCodeElements<TShortCode>[number]\n>(\n  namespace: TShortCode,\n  element: TElement,\n  defaultValue?: any\n): DetailProperty<TShortCode, TElement>;\nexport function createDetailProperty<\n  TShortCode extends ShortCodes,\n  TElement extends string\n>(\n  namespace: TShortCode,\n  element: TElement,\n  defaultValue?: any\n): DetailProperty<TShortCode, TElement>;\nexport function createDetailProperty<\n  TShortCode extends ShortCodes\n>(\n  namespace: TShortCode,\n  element: string,\n  defaultValue?: any\n): DetailProperty<TShortCode, string> {\n  if (!SHORT_CODE_TO_NAMESPACE[namespace]) {\n    throw new BadArgumentError(`Unknown namespace shortcode: ${namespace}`);\n  }\n\n  return {\n    namespaceShort: namespace,\n    namespace: SHORT_CODE_TO_NAMESPACE[namespace].full,\n    element,\n    default: defaultValue\n  };\n}\n\n/**\n * Converts a list of detail properties to an XML string.\n * @param details The prperties to convert to XML\n * @returns An XML string\n *\n * @note This is used internally by the client, but is exposed for use with the `propfind` method.\n * @see https://docs.nextcloud.com/server/latest/developer_manual/client_apis/WebDAV/basic.html#requesting-properties\n *\n * @example\n * const details = [\n * createDetailProperty('oc', 'fileid'),\n * createDetailProperty('oc', 'permissions'),\n * ];\n *\n * const xml = fileDetailsToXMLString(details);\n * // `<?xml version=\"1.0\" encoding=\"UTF-8\"?><d:propfind xmlns:d=\"DAV:\" xmlns:oc=\"http://owncloud.org/ns\"><d:prop><oc:fileid /><oc:permissions /></d:prop></d:propfind>`\n */\nexport function fileDetailsToXMLString(details: DetailProperty<any, any>[]) {\n  const namespaces = [\n    ...new Set(\n      details\n        .map(detail => detail.namespaceShort)\n        .concat('d')\n    )\n  ]\n    .map(short => `xmlns:${short}=\"${SHORT_CODE_TO_NAMESPACE[short].full}\"`);\n\n  const elements = details.map(detail => `<${detail.namespaceShort}:${detail.element} />`);\n\n  return `<?xml version=\"1.0\" encoding=\"UTF-8\"?><d:propfind ${namespaces.join(' ')}><d:prop>${elements.join('\\n')}</d:prop></d:propfind>`;\n}\n","import * as Stream from \"stream\"\n\nimport { Result, Optional } from \"lonad\";\n\nimport type {\n  WebDAVClientOptions,\n  StatOptions,\n  BufferLike,\n  CreateDirectoryOptions,\n  CreateReadStreamOptions,\n  CreateWriteStreamOptions,\n  FileStat,\n  GetDirectoryContentsOptions,\n  GetFileContentsOptions,\n  PutFileContentsOptions,\n  ResponseDataDetailed,\n  WebDAVMethodOptions,\n  WebDAVClient as WebDAVClientType,\n} from \"webdav\";\n\n\nimport { BadArgumentError } from \"./errors\";\n\nimport { wrapClient, wrapError } from \"./webdav.wrapper\";\n\nimport {\n  DetailProperty,\n  fileDetailsToXMLString,\n  createDetailProperty,\n  ExtractDetailProperties,\n} from \"./webdav.utils\";\n\nconst defaultProperties = [\n  createDetailProperty(\"d\", \"creationdate\"),\n  createDetailProperty(\"d\", \"getlastmodified\"),\n  createDetailProperty(\"d\", \"getetag\"),\n  createDetailProperty(\"d\", \"resourcetype\"),\n  createDetailProperty(\"d\", \"getcontentlength\"),\n  createDetailProperty(\"d\", \"getcontenttype\"),\n  createDetailProperty(\"oc\", \"fileid\"),\n  createDetailProperty(\"oc\", \"owner-id\"),\n];\n\nexport type WebDAVMethodOptionProperties<\n  TPROPS extends DetailProperty<any, any>[]\n> = {\n  properties?: TPROPS;\n};\n\n/**\n * A WebDAV client for specific for Nextcloud instances.\n * @param url The url to the Nextcloud instance.\n * @param options Optional options for the client.\n */\nexport class WebDavClient {\n  private client: WebDAVClientType;\n  private root: string;\n\n  // Empty private constructor to prevent instantiation\n  private constructor() {}\n\n  /**\n   * WebDAV client factory method. Creates a new WebDAV client for the given url.\n   *\n   * @param url The url to the Nextcloud instance.\n   * @param options Optional options for the client.\n   */\n  public static async create(url: string, options: WebDAVClientOptions = {}) {\n    const thisClient = new WebDavClient();\n    thisClient.root = nextCloudPath(options.username);\n    thisClient.client = await thisClient.loadClient(url, options);\n    return thisClient;\n  }\n\n  private async loadClient(url: string, options: WebDAVClientOptions = {}) {\n    // We need to use dynamic imports here since the webdav package only works in esm.\n    // We also need to use the `Function` constructor since the `import` keyword is compiled to `require` by typescript.\n    const webDav = await (Function('return import(\"webdav\");')() as Promise<typeof import(\"webdav\")>);\n\n    if (!webDav) {\n      throw new Error(\"Could not load webdav package\");\n    }\n\n    return wrapClient(\n      webDav.createClient(nextcloudRoot(url, this.root), options)\n    );\n  }\n\n  /**\n   * Returns the path to the root url.\n   */\n  public getPath() {\n    return this.root;\n  }\n\n  /**\n   * Checks whether the client is ready.\n   * @returns A promise that connects to the server.\n   *\n   * @example\n   * checkConnectivity()\n   *    .then(() => console.log('Connected'))\n   *    .catch((error) => console.error(error));\n   */\n  public async checkConnectivity() {\n    return Result.fromPromise(this.client.getDirectoryContents(\"/\"))\n      .map(Boolean)\n      .getOrElse(false);\n  }\n\n  /**\n   * Checks whether the given path exists on the server.\n   * @param path The path to the file or folder\n   * @param options Optional options for the method. See the [WebDAVMethodOptions](https://www.npmjs.com/package/webdav/v/4.11.2#method-options) interface for more information.\n   * @returns\n   * - `true` if the path exists\n   * - `false` if the path does not exist\n   *\n   * @example\n   * exists('/foo/bar')\n   *  .then((exists) => console.log(exists))\n   */\n  public async exists(\n    path: string,\n    options: WebDAVMethodOptions = {}\n  ): Promise<boolean> {\n    return Result.fromPromise((this.client.exists as any)(path, options))\n      .recover(() => false)\n      .toPromise();\n  }\n\n  /**\n   *\n   * @param path The path to the file or folder\n   * @param options Optional options for the method.\n   * @returns A promise that creates the directory.\n   *\n   * @throws {NextcloudError} If an error occurs.\n   *\n   * @example\n   * touchFolder('/foo/bar')\n   *  .then(() => console.log('Folder created'))\n   *  .catch((error) => console.error(error));\n   */\n  public async touchFolder(\n    path: string,\n    options: CreateDirectoryOptions = { recursive: true }\n  ) {\n    return Result.fromPromise(this.exists(path))\n      .reject(Boolean)\n      .expectMap(() => this.client.createDirectory(path, options))\n      .map(() => true)\n      .recover(() => false)\n      .toPromise();\n  }\n\n  /**\n   * Renames a file or folder.\n   * @param path The path to the file or folder\n   * @param newName The new name of the file or folder\n   * @param options Optional options for the method. See the [WebDAVMethodOptions](https://www.npmjs.com/package/webdav/v/4.11.2#method-options) interface for more information.\n   * @returns A promise that renames the file or folder.\n   *\n   * @throws {NextcloudError} If an error occurs.\n   *\n   * @example\n   * rename('/foo/bar', 'baz') // Renames the folder /foo/bar to /foo/baz\n   *  .then(() => console.log('Renamed'))\n   *  .catch((error) => console.error(error));\n   */\n  public async rename(\n    path: string,\n    newName: string,\n    options: WebDAVMethodOptions = {}\n  ): Promise<void> {\n    const basePath = Optional.fromNullable(path)\n      .reject((path) => path === \"\")\n      .map((path) => path.slice(0, path.lastIndexOf(\"/\") + 1));\n\n    const newPath = Optional.fromNullable(newName)\n      .reject((path) => path === \"\")\n      .flatMap((newName) => basePath.map((basePath) => basePath + newName));\n\n    return Result.expect(newPath)\n      .abortOnErrorWith(() => new BadArgumentError(\"New name must not be empty.\"))\n      .map((newPath) => this.move(path, newPath, options))\n      .toPromise();\n  }\n\n  /**\n   * Moves a file or folder.\n   * @param path The path to the file or folder\n   * @param destination The destination path\n   * @param options Optional options for the method. See the [WebDAVMethodOptions](https://www.npmjs.com/package/webdav/v/4.11.2#method-options) interface for more information.\n   * @returns A promise that moves the file or folder.\n   *\n   * @throws {NextcloudError} If an error occurs.\n   *\n   * @example\n   * move('/foo/bar', '/bar/foo') // Moves the folder /foo/bar to /bar/foo\n   *  .then(() => console.log('Moved'))\n   *  .catch((error) => console.error(error));\n   */\n  public async move(\n    path: string,\n    destination: string,\n    options: WebDAVMethodOptions = {}\n  ): Promise<void> {\n    return (this.client.moveFile as any)(path, destination, options);\n  }\n\n  /**\n   * Deletes a file or folder.\n   * @param path The path to the file or folder\n   * @param options Optional options for the method. See the [WebDAVMethodOptions](https://www.npmjs.com/package/webdav/v/4.11.2#method-options) interface for more information.\n   * @returns A promise that deletes the file or folder.\n   *\n   * @throws {NextcloudError} If an error occurs.\n   * @throws {NotFoundError} If the file or folder does not exist.\n   *\n   * @example\n   * remove('/foo/bar') // Deletes the folder /foo/bar\n   *    .then(() => console.log('Deleted'))\n   *    .catch((error) => console.error(error));\n   */\n  public async remove(\n    path: string,\n    options: WebDAVMethodOptions = {}\n  ): Promise<void> {\n    return (this.client.deleteFile as any)(path, options);\n  }\n\n  /**\n   *\n   * @param path The path to the file or folder\n   * @param content The content to write to the file\n   * @param options Optional options for the method. See the [PutFileContentsOptions](https://www.npmjs.com/package/webdav/v/4.11.2#user-content-putfilecontents) interface for more information.\n   * @returns A promise that writes the content to the file.\n   *  `true` if the file was written.\n   *  `false` otherwise.\n   */\n  public async put(\n    path: string,\n    content: string | BufferLike | Stream.Readable,\n    options?: PutFileContentsOptions\n  ) {\n    return this.client.putFileContents(path, content, options);\n  }\n\n  /**\n   * Gets the content of a file.\n   * @param path The path to the file\n   * @param options The options for the method. See the [GetFileContentsOptions](https://www.npmjs.com/package/webdav/v/4.11.2#user-content-getfilecontents) interface for more information.\n   * @returns A promise that gets the content of the file.\n   */\n  public async get(path: string, options?: GetFileContentsOptions) {\n    return this.client.getFileContents(path, options);\n  }\n\n  /**\n   * Creates a folder at the given path. Nested or non-existent folders will be created.\n   * @param path The path to the file or folder\n   * @returns A promise that creates the folder.\n   *\n   * @deprecated Use `touchFolder` instead.\n   * @example\n   *\n   * createFolder('/foo/bar') // Creates the folder /foo/bar\n   */\n  public async createFolderHierarchy(path: string): Promise<boolean> {\n    return this.touchFolder(path, { recursive: true });\n  }\n\n  /**\n   * Get all files and folders in the given folder.\n   * @param path The path to the file or folder\n   * @param options Optional options for the method.\n   * @returns A promise that gets the files and folders in the given folder.\n   *\n   * @throws {NextcloudError} If an error occurs.\n   * @throws {NotFoundError} If the folder does not exist.\n   *\n   * @example\n   * getFilesDetailed('/foo/bar') // Gets all files and folders in /foo/bar\n   */\n  public async getFilesDetailed<TProps extends DetailProperty<any, any>[]>(\n    path: string,\n    options: GetDirectoryContentsOptions & {\n      details: true;\n    } & WebDAVMethodOptionProperties<TProps>\n  ): Promise<\n    ResponseDataDetailed<\n      (FileStat & { props: Record<ExtractDetailProperties<TProps>, any> })[]\n    >\n  >;\n  public async getFilesDetailed(\n    path: string,\n    options: GetDirectoryContentsOptions & { details?: false | undefined }\n  ): Promise<FileStat[]>;\n  public async getFilesDetailed(\n    path: string,\n    options?: GetDirectoryContentsOptions\n  ): Promise<FileStat[]>;\n  public async getFilesDetailed(\n    path: string,\n    options: GetDirectoryContentsOptions = {}\n  ) {\n    const formattedOptions = formatOptions(options);\n\n    return Result.fromPromise(\n      this.client.getDirectoryContents(path, formattedOptions)\n    )\n      .map((result) => {\n        if (isDetailedResult(result)) {\n          result.data = result.data.map((file) => ({\n            ...file,\n            props: setDefaults(file, formattedOptions.properties),\n          }));\n        } else {\n          result = result.map((file) => ({\n            ...file,\n            props: setDefaults(file, formattedOptions.properties),\n          }));\n        }\n\n        return result;\n      })\n      .toPromise();\n  }\n\n  /**\n   * Get all files and folders in the given folder.\n   * @param path The path to the file or folder\n   * @returns A promise that gets all files and folders in the given folder.\n   *\n   * @throws {NextcloudError} If an error occurs.\n   * @throws {NotFoundError} If the folder does not exist.\n   *\n   * @deprecated Use `getFilesDetailed` instead.\n   *\n   * @example\n   * getFiles('/foo/bar') // Gets all files and folders in /foo/bar\n   */\n  public async getFiles(path: string): Promise<string[]> {\n    return Result.fromPromise(this.getFilesDetailed(path, { details: false }))\n      .map((files) => files.map((file) => file.basename))\n      .toPromise();\n  }\n\n  /**\n   * Get all file and folder details in the given folder.\n   * @param path The path to the file or folder\n   * @returns A promise that gets all files and folders in the given folder.\n   *\n   * @throws {NextcloudError} If an error occurs.\n   * @throws {NotFoundError} If the folder does not exist.\n   *\n   * @deprecated Use `getFilesDetailed` instead.\n   *\n   * @example\n   * getFolderFileDetails('/foo/bar') // Gets all files and folders in /foo/bar\n   */\n  public async getFolderFileDetails(\n    path: string,\n    extraProperties?: DetailProperty<any, string>[]\n  ) {\n    return Result.fromPromise(\n      this.getFilesDetailed(path, {\n        details: true,\n        properties: extraProperties,\n      })\n    )\n      .map((files) => files.data)\n      .map((files) =>\n        files.map((file) => ({\n          ...file,\n          isFile: file.type === \"file\",\n          isDirectory: file.type === \"directory\",\n          lastModified: file.lastmod,\n          href: `${this.root}${path}/${file.basename}`,\n          name: file.basename,\n          extraProperties: (file.props || {}) as typeof file.props,\n        }))\n      )\n      .toPromise();\n  }\n\n  /**\n   * Get the details of a file or folder.\n   * @param path The path to the file or folder\n   * @param options Optional options for the method.\n   * @returns A promise that gets the details of the file or folder.\n   *\n   * @throws {NextcloudError} If an error occurs.\n   * @throws {NotFoundError} If the file or folder does not exist.\n   *\n   * @example\n   * getPathInfo('/foo/bar') // Gets the details of /foo/bar\n   */\n  public async getPathInfo<TProps extends DetailProperty<any, any>[]>(\n    path: string,\n    options: StatOptions & {\n      details: true;\n    } & WebDAVMethodOptionProperties<TProps>\n  ): Promise<\n    ResponseDataDetailed<\n      FileStat & { props: Record<ExtractDetailProperties<TProps>, any> }\n    >\n  >;\n  public async getPathInfo(\n    path: string,\n    options: StatOptions & { details?: false | undefined }\n  ): Promise<FileStat>;\n  public async getPathInfo(\n    path: string,\n    options?: StatOptions\n  ): Promise<FileStat>;\n  public async getPathInfo(path: string, options: StatOptions = {}) {\n    const formattedOptions = formatOptions(options);\n\n    return Result.fromPromise(this.client.stat(path, formattedOptions))\n      .map((result) => {\n        if (isDetailedResult(result)) {\n          result.data.props = setDefaults(\n            result.data,\n            formattedOptions.properties\n          );\n        } else {\n          result.props = setDefaults(result, formattedOptions.properties);\n        }\n\n        return result;\n      })\n      .toPromise();\n  }\n\n  /**\n   * Get the details of a file or folder.\n   * @param path The path to the file or folder\n   * @param extraProperties The extra properties to get\n   * @returns A promise that gets the details of the file or folder.\n   *\n   * @deprecated Use `getPathInfo` instead.\n   */\n  public async getFolderProperties(\n    path: string,\n    extraProperties?: DetailProperty<any, string>[]\n  ): Promise<FileStat & Record<string, any>> {\n    const res = await this.getPathInfo(path, {\n      details: true,\n      properties: extraProperties,\n    });\n    const data = Result.expect(res.data)\n      .map((data) => ({\n        ...data,\n        ...extraProperties.reduce(\n          (acc, curr) => ({\n            ...acc,\n            [`${curr.namespaceShort}:${curr.element}`]:\n              data.props[curr.element],\n          }),\n          {}\n        ),\n      }))\n      .getOrElse(res.data);\n\n    return data;\n  }\n\n  /**\n   * Get a read stream for a file.\n   * @param path The path to the file or folder\n   * @param options Optional options for the method.\n   * @returns A promise which returns a read stream.\n   *\n   * @note Although the stream is returned immediately, the stream will only start downloading once the stream is connected to a destination.\n   */\n  public async getReadStream(\n    path: string,\n    options?: CreateReadStreamOptions\n  ): Promise<Stream.Readable> {\n    const readStream = new Stream.PassThrough();\n\n    await this.get(path, { details: false });\n\n    const remoteReadStream = await this.client.createReadStream(path, options);\n    remoteReadStream.pipe(readStream);\n\n    remoteReadStream.on(\"error\", (err) =>\n      readStream.emit(\"error\", wrapError(err, path))\n    );\n\n    return readStream;\n  }\n\n  /**\n   * Get a write stream for a file.\n   * @param path The path to the file or folder\n   * @param options Optional options for the method.\n   * @returns A promise which returns a write stream.\n   *\n   * @note Although the stream is returned immediately, the stream will only start uploading once the stream is connected to a destination.\n   * @note The write stream will only start uploading once the stream is closed.\n   * @note The write stream will emit a `finished` event once the upload has finished.\n   */\n  public async getWriteStream(\n    path: string,\n    options?: CreateWriteStreamOptions & { onFinished: () => void }\n  ): Promise<Stream.Writable> {\n    const writeStream = new Stream.PassThrough();\n    const { overwrite = false, ...otherOptions } = options ?? {};\n\n    await this.put(path, \"\", { overwrite, ...otherOptions });\n\n    this.put(path, writeStream, { overwrite, ...otherOptions })\n      .then(() => options?.onFinished())\n      .catch((err) => writeStream.emit(\"error\", wrapError(err)));\n\n    return writeStream;\n  }\n\n  /**\n   * Upload to a file from a stream.\n   * @param path The path to the file\n   * @param readStream The read stream to upload\n   * @returns A promise that uploads the given stream to the given path.\n   */\n  public async uploadFromStream(\n    path: string,\n    readStream: Stream.Readable\n  ): Promise<void> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const writeStream = await this.getWriteStream(path, {\n          overwrite: true,\n          onFinished: () => resolve(),\n        });\n\n        writeStream.on(\"error\", (err) => reject(err));\n\n        return await pipeStreams(readStream, writeStream);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n\n  /**\n   * Download a file to a stream.\n   * @param path The path to the file\n   * @param writeStream The write stream to download to\n   * @returns A promise that downloads the given path to the given stream.\n   */\n  public async downloadToStream(\n    path: string,\n    writeStream: Stream.Writable\n  ): Promise<void> {\n    const readStream = await this.getReadStream(path);\n\n    await pipeStreams(readStream, writeStream);\n  }\n}\n\n/**\n * Returns the root URL for the Nextcloud instance\n * @param url The Nextcloud instance URL\n * @param username The Nextcloud username\n * @returns The root URL for the Nextcloud instance\n * @private\n *\n * @example\n * nextcloudRoot('https://example.com/nextcloud', 'jack');\n * // => 'https://example.com/nextcloud/remote.php/dav/files/jack/'\n */\nfunction nextcloudRoot(url: string, path: string) {\n  const urlNoTrailingSlash = url.trimEnd().replace(/\\/$/, \"\");\n  const pathNoLeadingSlash = path.trimStart().replace(/^\\//, \"\");\n\n  return `${urlNoTrailingSlash}/${pathNoLeadingSlash}`;\n}\n\nfunction nextCloudPath(username: string) {\n  return `/remote.php/dav/files/${username}`;\n}\n\nfunction formatOptions(\n  options?: WebDAVMethodOptionProperties<any> & {\n    data?: WebDAVMethodOptions[\"data\"];\n    details?: boolean;\n    properties?: DetailProperty<any, any>[];\n  }\n) {\n  if (!options || !options.details) {\n    return options;\n  }\n\n  const props = defaultProperties.concat(options.properties ?? []);\n  const data = !options.data\n    ? Result.expect(props)\n        .filter((properties) => properties.length > 0)\n        .map((properties) => fileDetailsToXMLString(properties as any))\n        .getOrElse(options.data)\n    : options.data;\n\n  return {\n    ...options,\n    data: data,\n    properties: props,\n  };\n}\n\n/**\n * Sets the defaults for the given result\n * @param result The result to set the defaults for\n * @param props The properties to set the defaults for\n * @returns The result with the defaults set\n */\nfunction setDefaults(result: FileStat, props: DetailProperty<any, any>[]) {\n  return {\n    ...props?.reduce(\n      (acc, curr) => ({\n        ...acc,\n        [curr.element]: curr.default,\n      }),\n      {}\n    ),\n    ...result.props,\n  };\n}\n\n/**\n * Checks if the given result is a detailed result\n * @param result The result to check\n * @returns Whether the result is a detailed result\n */\nfunction isDetailedResult<TResult>(\n  result: TResult | {}\n): result is ResponseDataDetailed<any> {\n  return result.hasOwnProperty(\"data\") && result.hasOwnProperty(\"status\");\n}\n\n/**\n * Pipes a read stream to a write stream\n * @param readStream The read stream\n * @param writeStream The write stream\n * @returns A promise that resolves when the streams have been piped\n */\nasync function pipeStreams(\n  readStream: Stream.Readable,\n  writeStream: Stream.Writable\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    readStream.on(\"error\", fail);\n    writeStream.on(\"error\", fail);\n\n    // event from WebDav.Stream's deprecated request in case of uploadFromStream\n    writeStream.on(\"end\", resolve);\n\n    // event from Node.js write stream in case of downloadToStream\n    writeStream.on(\"close\", resolve);\n\n    readStream.pipe(writeStream);\n\n    function fail(error: Error) {\n      reject(wrapError(error));\n    }\n  });\n}\n","import { NotFoundError } from './errors';\nimport type { NextcloudClientInterface }         from './types';\nimport { createDetailProperty } from './webdav.utils';\n\nexport async function getCreatorByPath(path: string) : Promise<string> {\n  const self: NextcloudClientInterface = this;\n\n  let result = null;\n\n  try {\n    const folderProperties = await self.getPathInfo(path, {\n      details: true,\n      properties: [\n        createDetailProperty('oc', 'fileid')\n      ]\n    });\n\n    const fileId = folderProperties.data.props.fileid as string;\n    result = await self.getCreatorByFileId(fileId);\n  } catch {\n    result = Promise.reject(new NotFoundError(`Unable to find the creator for '${path}'`));\n  }\n\n  return result;\n}\n\nexport async function getCreatorByFileId(fileId: number | string) : Promise<string> {\n  const self: NextcloudClientInterface = this;\n\n  let result = null;\n\n  try {\n    const activities = await self.activities.get(fileId, 'asc', 1);\n    const fileCreatedActivity = activities\n    .find(activity => activity.type === 'file_created');\n\n    result = fileCreatedActivity.user;\n  } catch {\n    result = Promise.reject(new NotFoundError(`Unable to find the creator for fileId '${fileId}'`));\n  }\n\n  return result;\n}\n","export interface OcsActivity {\n  activityId:  number;\n  app:         string;\n  type:        string;\n  user:        string;\n  subject:     string;\n  subjectRich: [];\n  message:     string;\n  messageRich: [];\n  objectType:  string;\n  fileId:      number;\n  objectName:  string;\n  objects:     {};\n  link:        string;\n  icon:        string;\n  datetime:    Date;\n}\n\nexport interface OcsUser {\n  id:          string;\n  enabled:     boolean;\n  lastLogin:   number;\n  email:       string;\n  displayname: string;\n  phone:       string;\n  address:     string;\n  website:     string;\n  twitter:     string;\n  groups:      string[];\n  language:    string;\n  locale:      string;\n}\n\nexport interface OcsNewUser {\n  userid:       string;\n  password?:    string;\n  email?:       string;\n  displayName?: string;\n  groups?:      string[];\n  subadmin?:    string[];\n  quota?:       number;\n  language?:    string;\n}\n\nexport type OcsEditUserField =\n  'password'    |\n  'email'       |\n  'displayname' |\n  'quota'       |\n  'phone'       |\n  'address'     |\n  'website'     |\n  'twitter'     |\n  'locale'      |\n  'language'    ;\n\nexport interface OcsHttpError {\n  code:         number;\n  message:      string;\n  meta?: {\n    status:     string;\n    statuscode: number;\n    message:    string;\n  };\n}\n\nexport enum OcsShareType {\n  user                = 0,\n  group               = 1,\n  publicLink          = 3,\n  federatedCloudShare = 6,\n}\n\nexport enum OcsSharePermissions {\n  default = -1,\n  read    =  1,\n  update  =  2,\n  create  =  4,\n  delete  =  8,\n  share   = 16,\n  all     = 31,\n}\n\nexport interface OcsShare {\n  id:                    number;\n  shareType:             OcsShareType;\n  shareTypeSystemName:   string;\n  ownerUserId:           string;\n  ownerDisplayName:      string;\n  permissions:           OcsSharePermissions;\n  permissionsText:       string;\n  sharedOn:              Date;\n  sharedOnTimestamp:     number;\n  parent:                string;\n  expiration:            Date;\n  token:                 string;\n  fileOwnerUserId:       string;\n  fileOwnerDisplayName:  string;\n  note:                  string;\n  label:                 string;\n  path:                  string;\n  itemType:              'file' | 'folder';\n  mimeType:              string;\n  storageId:             string;\n  storage:               number;\n  fileId:                number;\n  parentFileId:          number;\n  fileTarget:            string;\n  sharedWith:            string;\n  sharedWithDisplayName: string;\n  mailSend:              boolean;\n  hideDownload:          boolean;\n  password?:             string;\n  sendPasswordByTalk?:   boolean;\n  url?:                  string;\n}\n\nexport type OcsEditShareField =\n  'permissions'     |\n  'password'        |\n  'publicUpload'    |\n  'expireDate'      |\n  'note'            ;\n\nexport interface OcsGroupfolderManageRule {\n  type:        'group' | 'user'\n  id:          string;\n  displayname: string;\n}\n\nexport interface OcsGroupfolder {\n  id:         number;\n  mountPoint: string;\n  groups:     Record<string, number>;\n  quota:      number;\n  size:       number;\n  acl:        boolean;\n  manage?:    OcsGroupfolderManageRule[];\n}\n","import { OcsSharePermissions } from './types';\nimport { OcsError }            from '../errors';\n\nexport interface ErrorInfo {\n  expectedErrorCodes?: number[];\n  customErrors?:    { [key: number]: string };\n  identifier?:     string | number;\n  message:         string;\n  useMeta:         boolean;\n}\n\ntype OmitLastParameter<TFn extends (...args: any[]) => any> = Parameters<TFn> extends [...infer PARAMS, any] ? PARAMS : Parameters<TFn>;\ntype LastParameter<TFn extends (...args: any[]) => any> = Parameters<TFn> extends [...any[], infer LAST] ? LAST : never;\n\ntype ExtractDataTypeFromCallback<TArgument> =\n  TArgument extends (err: any, data: infer TData) => any\n    ? TData\n    : never;\n\nexport function rejectWithOcsError(\n  error,\n  errorInfo: ErrorInfo\n) : Promise<never> {\n  let reason = error.message;\n  let statusCode = '';\n  if ((\n      errorInfo.expectedErrorCodes === undefined ||\n      errorInfo.expectedErrorCodes.includes(error.code)\n    ) && (\n      (errorInfo.useMeta && error.meta && error.meta.statuscode) ||\n      !errorInfo.useMeta\n  )) {\n    statusCode = (errorInfo.useMeta ? error.meta.statuscode : error.code);\n    reason = (errorInfo.useMeta ? error.meta.message : reason);\n\n    if (errorInfo.customErrors && errorInfo.customErrors.hasOwnProperty(statusCode)) {\n      reason = errorInfo.customErrors[statusCode];\n    }\n  }\n\n  return Promise.reject(new OcsError({\n    reason,\n    statusCode,\n    message: errorInfo.message,\n    identifier: errorInfo.identifier\n  }));\n}\n\nexport function assignDefined(target, ...sources) {\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const val = source[key];\n      if (val !== undefined) {\n        target[key] = val;\n      }\n    }\n  }\n}\n\nexport function ocsSharePermissionsToText(permissions: OcsSharePermissions) : string {\n  if (permissions === OcsSharePermissions.default) {\n    return '';\n  }\n  if (permissions === OcsSharePermissions.all) {\n    return 'all';\n  }\n\n  const result = [];\n  Object.keys(OcsSharePermissions).forEach(key => {\n    if (OcsSharePermissions[key] !== OcsSharePermissions.default && OcsSharePermissions[key] !== OcsSharePermissions.all) {\n      if ((permissions & OcsSharePermissions[key]) === OcsSharePermissions[key]) {\n        result.push(key);\n      }\n    }\n  });\n\n  return result.join('|');\n}\n\n/**\n * Promisify a function that takes a callback as its last parameter\n * @param fn The function to promisify\n * @returns A function that returns a promise\n *\n * @note This is a simple replacement for the `promisify` function from the `util` package which is not available in the browser (unless you polyfill it)\n */\nexport function promisify<\n  TFn extends (...args: any[]) => any,\n  CallbackData = ExtractDataTypeFromCallback<LastParameter<TFn>>\n>(fn: TFn): (...args: OmitLastParameter<TFn>) => Promise<CallbackData> {\n  return function (...args) {\n    const self = this;\n\n    return new Promise((resolve, reject)=> {\n      fn.call(self, ...args, function(err, res){\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      })\n    })\n  }\n}\n","import axios, { type AxiosError, type AxiosRequestConfig, type AxiosResponse } from 'axios';\n\n/**\n * Request wrapper.\n * @note Wrapper around axios to make it easier to use.\n */\nexport function req(options: AxiosRequestConfig, callback: (error?: any, response?: AxiosResponse, body?: any) => any): void {\n  axios({\n    method: 'GET',\n    validateStatus: () => true,\n    ...options\n  })\n    .then(async response =>  {\n      callback(null, response, response?.data);\n    })\n    .catch((error: AxiosError) => {\n      callback(error, null, null);\n    });\n}\n","import { AxiosResponse } from 'axios';\nimport type { ConnectionOptions } from '../types';\nimport { OcsHttpError }      from './types';\n\nexport class OcsConnection {\n  options : ConnectionOptions;\n\n  constructor(url: string)\n  constructor(options : ConnectionOptions)\n  constructor(options : string | ConnectionOptions) {\n    if (options.constructor === String) {\n      // tslint:disable-next-line: no-parameter-reassignment\n      options = { url: options as string };\n    }\n    this.options = options as ConnectionOptions;\n\n    if (this.options.url.lastIndexOf('/') === this.options.url.length - 1) {\n      this.options.url = this.options.url.substring(0, this.options.url.length - 1);\n    }\n  }\n\n  getHeader(withBody?: boolean) {\n    const credentials = Buffer.from(`${this.options.username}:${(this.options.password ? this.options.password : '')}`).toString('base64');\n    const header = {\n      'Content-Type': (withBody ? 'application/json' : 'application/x-www-form-urlencoded'),\n      'OCS-APIRequest' : 'true',\n      Accept: 'application/json',\n      Authorization: `Basic ${credentials}`\n    };\n\n    return header;\n  }\n\n  isValidResponse(body) : boolean {\n    return (body && body.ocs && body.ocs.meta);\n  }\n\n  request(error, response: AxiosResponse, body: string | object | undefined, callback: (error: OcsHttpError, body?: any) => any) {\n    if (error) {\n      callback(error, null);\n      return;\n    }\n\n    let jsonBody;\n\n    if (typeof body === 'object') {\n      jsonBody = body;\n    } else {\n      try {\n        jsonBody = JSON.parse(body || '{}');\n      } catch {\n        callback({\n          code: 500,\n          message: 'Unable to parse the response body as valid JSON.'\n        });\n      }\n    }\n\n    if (response.status !== 200) {\n      callback({\n        code: response.status,\n        message: response.statusText,\n        meta: (this.isValidResponse(jsonBody) ? jsonBody.ocs.meta : null)\n      }, null);\n\n      return;\n    }\n\n    if (this.isValidResponse(jsonBody)) {\n      // Response is well-formed\n      callback(null, jsonBody.ocs);\n    } else {\n      // Server said everything's fine but response is malformed\n      callback({\n        code: 500,\n        message: 'The server said everything was fine but returned a malformed body. This should never happen.'}\n      );\n    }\n  }\n}\n\nexport default OcsConnection;\n\n","import type {\n  OcsEditUserField,\n  OcsHttpError,\n  OcsNewUser,\n  OcsUser,\n} from './types';\nimport { OcsConnection } from './ocs-connection';\nimport { req } from '../requestWrapper';\n\nconst baseUrl = 'ocs/v2.php/cloud/users';\n\nexport function ocsGetUser(userId: string, callback: (error: OcsHttpError, result?: OcsUser) => void) : void {\n  const self: OcsConnection = this;\n\n  const urlParams = new URLSearchParams({\n    format: 'json'\n  }).toString();\n\n  // fetch(`${self.options.url}/${baseUrl}/${userId}?${urlParams}`, {\n  //   headers: self.getHeader()\n  // })\n  //   .then((response) => {\n  //     response.text()\n  //   })\n  //   .catch((error) => {\n  //     callback(error, null);\n  //   });\n\n  req({\n      url: `${self.options.url}/${baseUrl}/${userId}?${urlParams}`,\n      headers: self.getHeader()\n    }, (error, response, body) => {\n      self.request(error, response, body, (error: OcsHttpError, body?) => {\n        let result: OcsUser = null;\n\n        if (!error && body && body.data) {\n          result = {\n            id: body.data.id,\n            enabled: body.data.enabled,\n            lastLogin: body.data.lastLogin,\n            email: body.data.email,\n            displayname: body.data.displayname,\n            phone: body.data.phone,\n            address: body.data.address,\n            website: body.data.website,\n            twitter: body.data.twitter,\n            groups: body.data.groups,\n            language: body.data.language,\n            locale: body.data.locale\n          };\n        }\n\n        callback(error, result);\n      });\n    });\n}\n\nexport function ocsListUsers(\n  search: string,\n  limit: number,\n  offset: number,\n  callback: (error: OcsHttpError, result?: string[]) => void\n): void {\n  const self: OcsConnection = this;\n\n  const params = {\n    format: 'json',\n  };\n\n  if (search) {\n    params['search'] = search;\n  }\n\n  if (limit > -1) {\n    params['limit'] = limit;\n  }\n\n  if (offset > -1) {\n    params['offset'] = offset;\n  }\n\n  const urlParams = new URLSearchParams(params)\n    .toString();\n\n  req({\n    url: `${self.options.url}/${baseUrl}?${urlParams}`,\n    headers: self.getHeader()\n  }, (error, response, body) => {\n      self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let users: string[] = null;\n\n      if (!error && body && body.data && body.data.users) {\n        users = [];\n        body.data.users.forEach(user => {\n          users.push(user);\n        });\n      }\n\n      callback(error, users);\n    });\n  });\n}\n\nexport function ocsSetUserEnabled(\n  userId: string,\n  isEnabled: boolean,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${userId}/${isEnabled ? 'enable' : 'disable'}`,\n    method: 'PUT',\n    headers: self.getHeader()\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let success = false;\n      if (!error && body) {\n        success = true;\n      }\n\n      callback(error, success);\n    });\n  });\n}\n\nexport function ocsDeleteUser(userId: string, callback: (error: OcsHttpError, result?: boolean) => void): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${userId}`,\n    method: 'DELETE',\n    headers: self.getHeader()\n  }, (error, response, body) => {\n      self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let userDeleted = false;\n      if (!error && body) {\n        userDeleted = true;\n      }\n\n      callback(error, userDeleted);\n    });\n  });\n}\n\nexport function ocsAddUser(user: OcsNewUser, callback: (error: OcsHttpError, result?: boolean) => void): void {\n  const self: OcsConnection = this;\n\n  // Basic validation\n  if (!user) {\n    callback({ code: 0, message: 'must have a valid OcsNewUser object.' });\n    return;\n  }\n  if (!user.userid) {\n    callback({ code: 0, message: 'user must have an id.' });\n    return;\n  }\n\n  req({\n    url: `${self.options.url}/${baseUrl}`,\n    method: 'POST',\n    headers: self.getHeader(true),\n    data: JSON.stringify(user)\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let userAdded = false;\n      if (!error && body) {\n        userAdded = true;\n      }\n\n      callback(error, userAdded);\n    });\n  });\n}\n\nexport function ocsEditUser(\n  userId: string,\n  field: OcsEditUserField,\n  value: string,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${userId}`,\n    method: 'PUT',\n    headers: self.getHeader(true),\n    data: JSON.stringify({ value, key: field })\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let userEdited = false;\n      if (!error && body) {\n        userEdited = true;\n      }\n\n      callback(error, userEdited);\n    });\n  });\n}\n\nexport function ocsGetUserGroups(userId: string, callback: (error: OcsHttpError, result?: string[]) => void): void {\n  const self: OcsConnection = this;\n\n  // Basic validation\n  if (!userId) {\n    callback({ code: 0, message: 'no userId specified' });\n    return;\n  }\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${userId}/groups`,\n    headers: self.getHeader()\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groups: string[] = null;\n\n      if (!error && body && body.data && body.data.groups) {\n        groups = [];\n        body.data.groups.forEach(group => {\n          groups.push(group);\n        });\n      }\n\n      callback(error, groups);\n    });\n  });\n}\n\nexport function ocsAddRemoveUserForGroup(\n  userId: string,\n  groupId: string,\n  toAdd: boolean,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  // Basic validation\n  if (!userId) {\n    callback({ code: 0, message: 'no userId specified' });\n    return;\n  }\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${userId}/groups`,\n    method: (toAdd ? 'POST' : 'DELETE'),\n    headers: self.getHeader(true),\n    data: JSON.stringify({ groupid: groupId })\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let userModifiedForGroup = false;\n      if (!error && body) {\n        userModifiedForGroup = true;\n      }\n\n      callback(error, userModifiedForGroup);\n    });\n  });\n}\n\nexport function ocsSetUserSubAdmin(\n  userId: string,\n  groupId: string,\n  isSubAdmin: boolean,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  // Basic validation\n  if (!userId) {\n    callback({ code: 0, message: 'no userId specified' });\n    return;\n  }\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${userId}/subadmins`,\n    method: (isSubAdmin ? 'POST' : 'DELETE'),\n    headers: self.getHeader(true),\n    data: JSON.stringify({ groupid: groupId })\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let subAdminModifiedForGroup = false;\n      if (!error && body) {\n        subAdminModifiedForGroup = true;\n      }\n\n      callback(error, subAdminModifiedForGroup);\n    });\n  });\n}\n\nexport function ocsGetUserSubAdmins(userId: string, callback: (error: OcsHttpError, result?: string[]) => void): void {\n  const self: OcsConnection = this;\n\n  // Basic validation\n  if (!userId) {\n    callback({ code: 0, message: 'no userId specified' });\n    return;\n  }\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${userId}/subadmins`,\n    headers: self.getHeader()\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let subAdmins: string[] = null;\n\n      if (!error && body && body.data) {\n        subAdmins = [];\n        body.data.forEach(subAdmin => {\n          subAdmins.push(subAdmin);\n        });\n      }\n\n      callback(error, subAdmins);\n    });\n  });\n}\n\nexport function ocsResendUserWelcomeEmail(userId: string, callback: (error: OcsHttpError, result?: boolean) => void): void {\n  const self: OcsConnection = this;\n\n  // Basic validation\n  if (!userId) {\n    callback({ code: 0, message: 'no userId specified' });\n    return;\n  }\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${userId}/welcome`,\n    method: 'POST',\n    headers: self.getHeader()\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let success = false;\n      if (!error && body) {\n        success = true;\n      }\n\n      callback(error, success);\n    });\n  });\n}\n","import type {\n  OcsHttpError,\n} from './types';\n\nimport { OcsConnection } from './ocs-connection';\nimport { req } from '../requestWrapper';\n\nconst baseUrl = 'ocs/v2.php/cloud/groups';\n\nexport function ocsListGroups(\n  search: string,\n  limit: number,\n  offset: number,\n  callback: (error: OcsHttpError, result?: string[]) => void\n): void {\n  const self: OcsConnection = this;\n\n  const params = {\n    format: 'json',\n  };\n\n  if (search) {\n    params['search'] = search;\n  }\n\n  if (limit > -1) {\n    params['limit'] = limit;\n  }\n\n  if (offset > -1) {\n    params['offset'] = offset;\n  }\n\n  const urlParams = new URLSearchParams(params)\n    .toString();\n\n  req({\n    url: `${self.options.url}/${baseUrl}?${urlParams}`,\n    headers: self.getHeader()\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let result: string[] = null;\n\n      if (!error && body && body.data && body.data.groups) {\n        result = [];\n        body.data.groups.forEach(group => {\n          result.push(group);\n        });\n      }\n\n      callback(error, result);\n    });\n  });\n}\n\nexport function ocsAddGroup(groupId: string, callback: (error: OcsHttpError, result?: boolean) => void): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}`,\n    method: 'POST',\n    headers: self.getHeader(true),\n    data: JSON.stringify({\n      groupid: groupId\n    })\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupAdded = false;\n      if (!error && body) {\n        groupAdded = true;\n      }\n\n      callback(error, groupAdded);\n    });\n  });\n}\n\nexport function ocsDeleteGroup(groupId: string, callback: (error: OcsHttpError, result?: boolean) => void): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupId}`,\n    method: 'DELETE',\n    headers: self.getHeader(true)\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupDeleted = false;\n      if (!error && body) {\n        groupDeleted = true;\n      }\n\n      callback(error, groupDeleted);\n    });\n  });\n}\n\nexport function ocsGetGroupUsers(groupId: string, callback: (error: OcsHttpError, result?: string[]) => void): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupId}`,\n    headers: self.getHeader()\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let users: string[] = null;\n\n      if (!error && body && body.data && body.data.users) {\n        users = [];\n        body.data.users.forEach(user => {\n          users.push(user);\n        });\n      }\n\n      callback(error, users);\n    });\n  });\n}\n\nexport function ocsGetGroupSubAdmins(groupId: string, callback: (error: OcsHttpError, result?: string[]) => void): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupId}/subadmins`,\n    headers: self.getHeader()\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let subAdmins: string[] = null;\n\n      if (!error && body && body.data) {\n        subAdmins = [];\n        body.data.forEach(subAdmin => {\n          subAdmins.push(subAdmin);\n        });\n      }\n\n      callback(error, subAdmins);\n    });\n  });\n}\n","import {\n  OcsSharePermissions,\n  OcsShareType,\n  type OcsEditShareField,\n  type OcsHttpError,\n  type OcsShare,\n} from './types';\n\nimport { OcsConnection } from './ocs-connection';\nimport { assignDefined, ocsSharePermissionsToText } from './helper';\nimport { req } from '../requestWrapper';\n\nconst baseUrl = 'ocs/v2.php/apps/files_sharing/api/v1/shares';\n\nexport function ocsGetShares(\n  path: string,\n  includeReshares: boolean,\n  showForSubFiles: boolean,\n  callback: (error: OcsHttpError, result?: OcsShare[]) => void\n): void {\n  const self: OcsConnection = this;\n\n  const params = {\n    format: 'json'\n  };\n\n  if (path) {\n    params['path'] = path;\n    params['reshares'] = includeReshares;\n    params['subfiles'] = showForSubFiles;\n  }\n\n  const urlParams = new URLSearchParams(params)\n    .toString();\n\n  req({\n    url: `${self.options.url}/${baseUrl}?${urlParams}`,\n    headers: self.getHeader()\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let result: OcsShare[] = null;\n\n      if (!error && body && body.data) {\n        result = [];\n        body.data.forEach(share => {\n          result.push(parseOcsShare(share));\n        });\n      }\n\n      callback(error, result);\n    });\n  });\n}\n\nexport function ocsGetShare(\n  shareId: number | string,\n  callback: (error: OcsHttpError, result?: OcsShare) => void\n): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${shareId}`,\n    headers: self.getHeader()\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let result: OcsShare = null;\n\n      if (!error && body && body.data && body.data.length > 0) {\n        result = parseOcsShare(body.data[0]);\n      }\n\n      callback(error, result);\n    });\n  });\n}\n\nexport function ocsDeleteShare(\n  shareId: number | string,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${shareId}`,\n    method: 'DELETE',\n    headers: self.getHeader()\n  }, (error, response, body) => {\n      self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let shareDeleted = false;\n      if (!error && body) {\n        shareDeleted = true;\n      }\n\n      callback(error, shareDeleted);\n    });\n  });\n}\n\nexport function ocsAddShare(\n  path: string,\n  shareType: OcsShareType,\n  shareWith: string,\n  permissions: OcsSharePermissions,\n  password: string,\n  publicUpload: boolean,\n  callback: (error: OcsHttpError, result?: OcsShare) => void\n): void {\n  const self: OcsConnection = this;\n\n  const share = {\n    path,\n    shareType,\n  };\n\n  share['publicUpload'] = String(publicUpload);\n\n  if (shareWith) {\n    share['shareWith'] = shareWith;\n  }\n\n  if (permissions && permissions !== OcsSharePermissions.default) {\n    share['permissions'] = permissions;\n  }\n\n  if (password) {\n    share['password'] = password;\n  }\n\n  req({\n    url: `${self.options.url}/${baseUrl}`,\n    method: 'POST',\n    headers: self.getHeader(true),\n    data: JSON.stringify(share)\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let result: OcsShare = null;\n      if (!error && body && body.data) {\n        result = parseOcsShare(body.data);\n      }\n\n      callback(error, result);\n    });\n  });\n}\n\nexport function ocsEditShare(\n  shareId: number | string,\n  field: OcsEditShareField,\n  value: string,\n  callback: (error: OcsHttpError, result?: OcsShare) => void\n) {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${shareId}`,\n    method: 'PUT',\n    headers: self.getHeader(true),\n    data: JSON.stringify({ [field]: value })\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let result: OcsShare = null;\n      if (!error && body && body.data) {\n        result = parseOcsShare(body.data);\n      }\n\n      callback(error, result);\n    });\n  });\n}\n\nfunction parseOcsShare(share) {\n  const timestamp = parseInt(share.stime, 10);\n  const permissionsInt = parseInt(share.permissions, 10);\n  const shareTypeInt = parseInt(share.share_type, 10);\n\n  const obj : OcsShare = {\n    id: parseInt(share.id, 10),\n    shareType: shareTypeInt,\n    shareTypeSystemName: OcsShareType[shareTypeInt],\n    ownerUserId: share.uid_owner,\n    ownerDisplayName: share.displayname_owner,\n    permissions: permissionsInt,\n    permissionsText: ocsSharePermissionsToText(permissionsInt),\n    sharedOn: new Date(timestamp * 1000),\n    sharedOnTimestamp: timestamp,\n    parent: share.parent,\n    expiration: share.expiration,\n    token: share.token,\n    fileOwnerUserId: share.uid_file_owner,\n    fileOwnerDisplayName: share.displayname_file_owner,\n    note: share.note,\n    label: share.label,\n    path: share.path,\n    itemType: share.item_type,\n    mimeType: share.mimetype,\n    storageId: share.storage_id,\n    storage: parseInt(share.storage, 10),\n    fileId: parseInt(share.item_source, 10),\n    parentFileId: parseInt(share.file_parent, 10),\n    fileTarget: share.file_target,\n    sharedWith: share.share_with,\n    sharedWithDisplayName: share.share_with_displayname,\n    mailSend: Boolean(share.mail_send),\n    hideDownload: Boolean(share.hide_download),\n  };\n\n  assignDefined(obj, {\n    password: share.password,\n    sendPasswordByTalk: share.send_password_by_talk,\n    url: share.url,\n  });\n\n  return obj;\n}\n","import type {\n  OcsHttpError,\n  OcsGroupfolder,\n} from './types';\n\nimport { OcsConnection } from './ocs-connection';\nimport { req } from '../requestWrapper';\n\nconst baseUrl = 'apps/groupfolders/folders';\n\n// GET apps/groupfolders/folders: Returns a list of all configured groupfolders and their settings\nexport function ocsGetGroupfolders(\n  callback: (error: OcsHttpError, result?: OcsGroupfolder[]) => void\n): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}`,\n    headers: self.getHeader(true),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let result: OcsGroupfolder[] = null;\n\n      if (!error && body && body.data) {\n        result = [];\n\n        Object.values(body.data).forEach(groupfolder => {\n          result.push(parseOcsGroupfolder(groupfolder));\n        });\n      }\n\n      callback(error, result);\n    });\n  });\n}\n\n// GET apps/groupfolders/folders/$folderId: Return a specific configured groupfolder and its settings\n// returns groupfolder object if found, `null` otherwise\nexport function ocsGetGroupfolder(\n  groupfolderId: number,\n  callback: (error: OcsHttpError, result?: OcsGroupfolder) => void\n): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupfolderId}`,\n    headers: self.getHeader(true),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let result: OcsGroupfolder = null;\n\n      if (!error && body && body.data) {\n        result = parseOcsGroupfolder(body.data);\n      }\n\n      callback(error, result);\n    });\n  });\n}\n\n// POST apps/groupfolders/folders: Create a new groupfolder\n// `mountpoint`: The name for the new groupfolder\n// returns new groupfolder id\nexport function ocsAddGroupfolder(\n  mountpoint: string,\n  callback: (error: OcsHttpError, result?: number) => void\n): void {\n  const self: OcsConnection = this;\n\n  const body = {\n    mountpoint,\n  };\n\n  req({\n    url: `${self.options.url}/${baseUrl}`,\n    method: 'POST',\n    headers: self.getHeader(true), //! set `true` for POST requests\n    data: JSON.stringify(body),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let result: number = null;\n\n      if (!error && body && body.data) {\n        result = parseOcsGroupfolderId(body.data);\n      }\n\n      callback(error, result);\n    });\n  });\n}\n\n// DELETE apps/groupfolders/folders/$folderId: Delete a groupfolder\n// returns `true` if successful (even if the groupfolder didn't exist)\nexport function ocsRemoveGroupfolder(\n  groupfolderId: number,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupfolderId}`,\n    method: 'DELETE',\n    headers: self.getHeader(),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupfolderDeleted = false;\n\n      if (!error && body) {\n        groupfolderDeleted = true;\n      }\n\n      callback(error, groupfolderDeleted);\n    });\n  });\n}\n\n// POST apps/groupfolders/folders/$folderId/groups: Give a group access to a groupfolder\n// `group`: The id of the group to be given access to the groupfolder\n// returns `true` if successful (even if the group doesn't exist)\nexport function ocsAddGroupfolderGroup(\n  groupfolderId: number,\n  groupId: string,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  const body = {\n    group: groupId,\n  };\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupfolderId}/groups`,\n    method: 'POST',\n    headers: self.getHeader(true),\n    data: JSON.stringify(body)\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupfolderGroupAdded = false;\n\n      if (!error && body) {\n        groupfolderGroupAdded = true;\n      }\n\n      callback(error, groupfolderGroupAdded);\n    });\n  });\n}\n\n// DELETE apps/groupfolders/folders/$folderId/groups/$groupId: Remove access from a group to a groupfolder\n// returns `true` if successful (even if the groupfolder didn't exist)\nexport function ocsRemoveGroupfolderGroup(\n  groupfolderId: number,\n  groupId: string,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupfolderId}/groups/${groupId}`,\n    method: 'DELETE',\n    headers: self.getHeader(),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupfolderGroupRemoved = false;\n\n      if (!error && body) {\n        groupfolderGroupRemoved = true;\n      }\n\n      callback(error, groupfolderGroupRemoved);\n    });\n  });\n}\n\n// POST apps/groupfolders/folders/$folderId/groups/$groupId: Set the permissions a group has in a groupfolder\n// `permissions` The new permissions for the group as bitmask of permissions constants\n// e.g. write(6) === update(2) + create(4)\nexport function ocsSetGroupfolderPermissions(\n  groupfolderId: number,\n  groupId: string,\n  permissions: number,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  const body = {\n    permissions,\n  };\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupfolderId}/groups/${groupId}`,\n    method: 'POST',\n    headers: self.getHeader(true),\n    data: JSON.stringify(body),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupfolderPermissionsSet = false;\n\n      if (!error && body) {\n        groupfolderPermissionsSet = true;\n      }\n\n      callback(error, groupfolderPermissionsSet);\n    });\n  });\n}\n\n// POST apps/groupfolders/folders/$folderId/acl: Enable/Disable groupfolder advanced permissions\n// `acl`: `true` for enable, `false` for disable.\nexport function ocsEnableOrDisableGroupfolderACL(\n  groupfolderId: number,\n  enable: boolean,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  const body = {\n    acl: enable ? 1 : 0\n  };\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupfolderId}/acl`,\n    method: 'POST',\n    headers: self.getHeader(true),\n    data: JSON.stringify(body),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupfolderACLset = false;\n\n      if (!error && body) {\n        groupfolderACLset = true;\n      }\n\n      callback(error, groupfolderACLset);\n    });\n  });\n}\n\n// POST apps/groupfolders/folders/$folderId/manageACL: Grants/Removes a group or user the ability to manage a groupfolders' advanced permissions\n// `mappingId`: the id of the group/user to be granted/removed access to/from the groupfolder\n// `mappingType`: 'group' or 'user'\n// `manageAcl`: true to grants ability to manage a groupfolders' advanced permissions, false to remove\nexport function ocsSetGroupfolderManageACL(\n  groupfolderId: number,\n  type: 'group' | 'user',\n  id: string,\n  manageACL: boolean,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  const body = {\n    mappingType: type,\n    mappingId: id,\n    manageAcl: manageACL ? 1 : 0\n  };\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupfolderId}/manageACL`,\n    method: 'POST',\n    headers: self.getHeader(true),\n    data: JSON.stringify(body),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupfolderPermissionsSet = false;\n\n      if (!error && body) {\n        groupfolderPermissionsSet = true;\n      }\n\n      callback(error, groupfolderPermissionsSet);\n    });\n  });\n}\n\n// POST apps/groupfolders/folders/$folderId/quota: Set the quota for a groupfolder in bytes\n// `quota`: The new quota for the groupfolder in bytes, user -3 for unlimited\nexport function ocsSetGroupfolderQuota(\n  groupfolderId: number,\n  quota: number,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  const body = {\n    quota: Number.isNaN(quota) ? -3 : quota,\n  };\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupfolderId}/quota`,\n    method: 'POST',\n    headers: self.getHeader(true),\n    data: JSON.stringify(body),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupfolderQuotaSet = false;\n\n      if (!error && body) {\n        groupfolderQuotaSet = true;\n      }\n\n      callback(error, groupfolderQuotaSet);\n    });\n  });\n}\n\n// POST apps/groupfolders/folders/$folderId/mountpoint: Change the name of a groupfolder\n// `mountpoint`: The new name for the groupfolder\nexport function ocsRenameGroupfolder(\n  groupfolderId: number,\n  mountpoint: string,\n  callback: (error: OcsHttpError, result?: boolean) => void\n): void {\n  const self: OcsConnection = this;\n\n  const body = {\n    mountpoint,\n  };\n\n  req({\n    url: `${self.options.url}/${baseUrl}/${groupfolderId}/mountpoint`,\n    method: 'POST',\n    headers: self.getHeader(true),\n    data: JSON.stringify(body),\n  }, (error, response, body) => {\n    self.request(error, response, body, (error: OcsHttpError, body?) => {\n      let groupfolderRenamed = false;\n\n      if (!error && body) {\n        groupfolderRenamed = true;\n      }\n\n      callback(error, groupfolderRenamed);\n    });\n  });\n}\n\nfunction parseOcsGroupfolder(groupfolder): OcsGroupfolder {\n  return {\n    id:         parseInt(groupfolder.id, 10),\n    mountPoint: groupfolder.mount_point,\n    groups:     groupfolder.groups,\n    quota:      groupfolder.quota,\n    size:       groupfolder.size,\n    acl:        groupfolder.acl,\n    manage:     groupfolder.manage,\n  };\n}\n\nfunction parseOcsGroupfolderId(groupfolder): number {\n  return parseInt(groupfolder.id, 10);\n}\n","import { promisify, rejectWithOcsError } from './helper';\nimport { ocsGetActivities }   from './activity';\nimport { OcsConnection }      from './ocs-connection';\n\nimport  {\n  OcsSharePermissions,\n  type OcsEditShareField,\n  type OcsEditUserField,\n  type OcsGroupfolder,\n  type OcsShareType,\n  type OcsActivity,\n  type OcsNewUser,\n  type OcsShare,\n  type OcsUser,\n} from './types';\n\nimport {\n  ocsResendUserWelcomeEmail,\n  ocsAddRemoveUserForGroup,\n  ocsGetUserSubAdmins,\n  ocsSetUserSubAdmin,\n  ocsSetUserEnabled,\n  ocsGetUserGroups,\n  ocsDeleteUser,\n  ocsListUsers,\n  ocsEditUser,\n  ocsAddUser,\n  ocsGetUser,\n} from './user';\n\nimport {\n  ocsGetGroupSubAdmins,\n  ocsGetGroupUsers,\n  ocsDeleteGroup,\n  ocsListGroups,\n  ocsAddGroup,\n} from './group';\n\nimport {\n  ocsDeleteShare,\n  ocsEditShare,\n  ocsGetShares,\n  ocsAddShare,\n  ocsGetShare,\n} from './share';\n\nimport {\n  ocsGetGroupfolders,\n  ocsGetGroupfolder,\n  ocsAddGroupfolder,\n  ocsRemoveGroupfolder,\n  ocsAddGroupfolderGroup,\n  ocsRemoveGroupfolderGroup,\n  ocsEnableOrDisableGroupfolderACL,\n  ocsRenameGroupfolder,\n  ocsSetGroupfolderQuota,\n  ocsSetGroupfolderPermissions,\n  ocsSetGroupfolderManageACL,\n} from './groupfolders';\n\nimport {\n  NextcloudClientInterface,\n  ConnectionOptions,\n} from '../types';\n\nconst promisifiedGetActivities                 = promisify(ocsGetActivities);\n\nconst promisifiedResendUserWelcomeEmail        = promisify(ocsResendUserWelcomeEmail);\nconst promisifiedAddRemoveUserForGroup         = promisify(ocsAddRemoveUserForGroup);\nconst promisifiedGetUserSubAdmins              = promisify(ocsGetUserSubAdmins);\nconst promisifiedSetUserSubAdmin               = promisify(ocsSetUserSubAdmin);\nconst promisifiedSetUserEnabled                = promisify(ocsSetUserEnabled);\nconst promisifiedGetUserGroups                 = promisify(ocsGetUserGroups);\nconst promisifiedDeleteUser                    = promisify(ocsDeleteUser);\nconst promisifiedListUsers                     = promisify(ocsListUsers);\nconst promisifiedEditUser                      = promisify(ocsEditUser);\nconst promisifiedAddUser                       = promisify(ocsAddUser);\nconst promisifiedGetUser                       = promisify(ocsGetUser);\n\nconst promisifiedGetGroupSubAdmins             = promisify(ocsGetGroupSubAdmins);\nconst promisifiedGetGroupUsers                 = promisify(ocsGetGroupUsers);\nconst promisifiedDeleteGroup                   = promisify(ocsDeleteGroup);\nconst promisifiedListGroups                    = promisify(ocsListGroups);\nconst promisifiedAddGroup                      = promisify(ocsAddGroup);\n\nconst promisifiedDeleteShare                   = promisify(ocsDeleteShare);\nconst promisifiedEditShare                     = promisify(ocsEditShare);\nconst promisifiedGetShares                     = promisify(ocsGetShares);\nconst promisifiedGetShare                      = promisify(ocsGetShare);\nconst promisifiedAddShare                      = promisify(ocsAddShare);\n\nconst promisifiedGetGroupfolders               = promisify(ocsGetGroupfolders);\nconst promisifiedGetGroupfolder                = promisify(ocsGetGroupfolder);\nconst promisifiedAddGroupfolder                = promisify(ocsAddGroupfolder);\nconst promisifiedRemoveGroupfolder             = promisify(ocsRemoveGroupfolder);\nconst promisifiedAddGroupfolderGroup           = promisify(ocsAddGroupfolderGroup);\nconst promisifiedRemoveGroupfolderGroup        = promisify(ocsRemoveGroupfolderGroup);\nconst promisifiedEnableOrDisableGroupfolderACL = promisify(ocsEnableOrDisableGroupfolderACL);\nconst promisifiedRenameGroupfolder             = promisify(ocsRenameGroupfolder);\nconst promisifiedSetGroupfolderQuota           = promisify(ocsSetGroupfolderQuota);\nconst promisifiedSetGroupfolderPermissions     = promisify(ocsSetGroupfolderPermissions);\nconst promisifiedSetGroupfolderManageACL       = promisify(ocsSetGroupfolderManageACL);\n\nexport function configureOcsConnection(options: ConnectionOptions): void {\n  const self: NextcloudClientInterface = this;\n\n  self.ocsConnection = new OcsConnection({\n    url:           options.url,\n    username:      options.username,\n    password:      options.password\n  });\n}\n\nexport async function getActivities(\n  connection: OcsConnection,\n  fileId: number | string,\n  sort?: 'asc' | 'desc',\n  limit?: number,\n  sinceActivityId?: number\n) : Promise<OcsActivity[]> {\n  let activities: Promise<OcsActivity[]>;\n\n  try {\n    activities = await promisifiedGetActivities.call(\n      connection,\n      (typeof fileId === 'string' ? parseInt(fileId, 10) : fileId),\n      sort || 'desc',\n      limit || -1,\n      sinceActivityId || -1\n    );\n  } catch (error) {\n    activities = rejectWithOcsError(error, {\n      message: 'Unable to get activities for',\n      identifier: fileId,\n      useMeta: false,\n      customErrors: {\n        [204]: 'The user has selected no activities to be listed in the stream',\n        [304]: 'ETag/If-None-Match are the same or the end of the activity list was reached',\n        [403]: 'The offset activity belongs to a different user or the user is not logged in',\n        [404]: 'The filter is unknown'\n      }\n    });\n  }\n\n  return activities;\n}\n\nexport async function getUser(\n  connection: OcsConnection,\n  userId: string\n) : Promise<OcsUser> {\n  let user: Promise<OcsUser>;\n\n  try {\n    user = await promisifiedGetUser.call(connection, userId);\n  } catch (error) {\n    user = rejectWithOcsError(error, {\n      message: 'Unable to find user',\n      identifier: userId,\n      useMeta: false\n    });\n  }\n\n  return user;\n}\n\nexport async function setUserEnabled(\n  connection: OcsConnection,\n  userId: string,\n  isEnabled: boolean\n): Promise<boolean> {\n  let success: Promise<boolean>;\n\n  try {\n    success = await promisifiedSetUserEnabled.call(connection, userId, isEnabled);\n  } catch (error) {\n    success = rejectWithOcsError(error, {\n      message: `Unable to ${isEnabled ? 'enable' : 'disable'} user`,\n      identifier: userId,\n      useMeta: true,\n      customErrors: {\n        [101]: 'user does not exist'\n      }\n    });\n  }\n\n  return success;\n}\n\nexport async function editUser(\n  connection: OcsConnection,\n  userId: string,\n  field: OcsEditUserField,\n  value: string\n): Promise<boolean> {\n  let userEdited: Promise<boolean>;\n\n  try {\n    userEdited = await promisifiedEditUser.call(connection, userId, field, value);\n  } catch (error) {\n    userEdited = rejectWithOcsError(error, {\n      message: 'Unable to edit user',\n      identifier: userId,\n      useMeta: true,\n      expectedErrorCodes: [400, 401],\n      customErrors: {\n        [101]: 'user not found',\n        [997]: 'possible reasons: Does it exist? Do you have the right permissions? Is the field valid?'\n      }\n    });\n  }\n\n  return userEdited;\n}\n\nexport async function getUserGroups(\n  connection: OcsConnection,\n  userId: string\n): Promise<string[]> {\n  let groups: Promise<string[]>;\n\n  try {\n    groups = await promisifiedGetUserGroups.call(connection, userId);\n  } catch (error) {\n    groups = rejectWithOcsError(error, {\n      message: 'Unable to get groups for user',\n      identifier: userId,\n      useMeta: false\n    });\n  }\n\n  return groups;\n}\n\nexport async function getUserSubAdmins(\n  connection: OcsConnection,\n  userId: string\n): Promise<string[]> {\n  let subAdmins: Promise<string[]>;\n\n  try {\n    subAdmins = await promisifiedGetUserSubAdmins.call(connection, userId);\n  } catch (error) {\n    subAdmins = rejectWithOcsError(error, {\n      message: 'Unable to get sub-admins for user',\n      identifier: userId,\n      useMeta: true,\n      expectedErrorCodes: [400],\n      customErrors: {\n        [101]: 'user does not exist'\n      }\n    });\n  }\n\n  return subAdmins;\n}\n\nexport async function resendUserWelcomeEmail(\n  connection: OcsConnection,\n  userId: string\n): Promise<boolean> {\n    let success: Promise<boolean>;\n\n    try {\n      success = await promisifiedResendUserWelcomeEmail.call(connection, userId);\n    } catch (error) {\n      success = rejectWithOcsError(error, {\n        message: 'Unable to resend welcome email for user',\n        identifier: userId,\n        useMeta: true,\n        expectedErrorCodes: [400],\n        customErrors: {\n          [101]: 'email address not available',\n          [102]: 'sending email failed'\n        }\n      });\n    }\n\n    return success;\n  }\n\nexport async function addRemoveUserForGroup(\n  connection: OcsConnection,\n  userId: string,\n  groupId: string,\n  toAdd: boolean\n): Promise<boolean> {\n  let userModifiedForGroup: Promise<boolean>;\n\n  try {\n    userModifiedForGroup = await promisifiedAddRemoveUserForGroup.call(connection, userId, groupId, toAdd);\n  } catch (error) {\n    userModifiedForGroup = rejectWithOcsError(error, {\n      message: `Unable to ${toAdd ? 'add' : 'remove'} user '${userId}' ${toAdd ? 'to' : 'from'} group`,\n      identifier: groupId,\n      useMeta: true,\n      expectedErrorCodes: [400],\n      customErrors: {\n        [101]: 'no group specified',\n        [102]: 'group does not exist',\n        [103]: 'user does not exist',\n        [104]: 'insufficient privileges',\n      }\n    });\n  }\n\n  return userModifiedForGroup;\n}\n\nexport async function addRemoveUserSubAdminForGroup(\n  connection: OcsConnection,\n  userId: string,\n  groupId: string,\n  toAdd: boolean\n): Promise<boolean> {\n  let subAdminModifiedForGroup: Promise<boolean>;\n\n  try {\n    subAdminModifiedForGroup = await promisifiedSetUserSubAdmin.call(connection, userId, groupId, toAdd);\n  } catch (error) {\n    let customErrors = {};\n    if (toAdd) {\n      customErrors[101] = 'user does not exist';\n      customErrors[102] = 'group does not exist';\n    } else {\n      customErrors[101] = 'user or group does not exist';\n      customErrors[102] = 'user is not a sub-admin of the group';\n    }\n\n    subAdminModifiedForGroup = rejectWithOcsError(error, {\n      customErrors,\n      message: `Unable to ${toAdd ? 'add' : 'remove'} user '${userId}' as sub-admin ${toAdd ? 'to' : 'from'} group`,\n      identifier: groupId,\n      useMeta: true,\n      expectedErrorCodes: [400],\n    });\n  }\n\n  return subAdminModifiedForGroup;\n}\n\nexport async function listUsers(\n  connection: OcsConnection,\n  search?: string,\n  limit?: number,\n  offset?: number\n): Promise<string[]> {\n  let users: Promise<string[]>;\n\n  try {\n    users = await promisifiedListUsers.call(connection,\n      search || '',\n      Number.isInteger(limit)  ? limit  : -1,\n      Number.isInteger(offset) ? offset : -1\n    );\n  } catch (error) {\n    users = rejectWithOcsError(error, {\n      message: 'Unable to list users',\n      useMeta: false\n    });\n  }\n\n  return users;\n}\n\nexport async function deleteUser(\n  connection: OcsConnection,\n  userId: string\n): Promise<boolean> {\n  let userDeleted: Promise<boolean>;\n\n  try {\n    userDeleted = await promisifiedDeleteUser.call(connection, userId);\n  } catch (error) {\n    userDeleted = rejectWithOcsError(error, {\n      message: 'Unable to delete user',\n      identifier: userId,\n      useMeta: true,\n      expectedErrorCodes: [400],\n      customErrors: {\n        [101]: 'user does not exist'\n      }\n    });\n  }\n\n  return userDeleted;\n}\n\nexport async function addUser(\n  connection: OcsConnection,\n  user: OcsNewUser\n): Promise<boolean> {\n  let userAdded: Promise<boolean>;\n\n  try {\n    userAdded = await promisifiedAddUser.call(connection, user);\n  } catch (error) {\n    userAdded = rejectWithOcsError(error, {\n      message: 'Unable to add user',\n      identifier: (user && user.userid ? user.userid : ''),\n      useMeta: true,\n      expectedErrorCodes: [400],\n      customErrors: {\n        [102]: 'username already exists',\n        [103]: 'unknown error occurred whilst adding the user',\n        [104]: 'group does not exist',\n        [105]: 'insufficient privileges for group',\n        [106]: 'no group specified (required for sub-admins',\n        [108]: 'password and email empty. Must set password or an email',\n        [109]: 'invitation email cannot be send'\n      }\n    });\n  }\n\n  return userAdded;\n}\n\nexport async function listGroups(\n  connection: OcsConnection,\n  search?: string,\n  limit?: number,\n  offset?: number\n): Promise<string[]> {\n  let groups: Promise<string[]>;\n\n  try {\n    groups = await promisifiedListGroups.call(\n      connection,\n      search || '',\n      Number.isInteger(limit)  ? limit  : -1,\n      Number.isInteger(offset) ? offset : -1\n    );\n  } catch (error) {\n    groups = rejectWithOcsError(error, {\n      message: 'Unable to list groups',\n      useMeta: false\n    });\n  }\n\n  return groups;\n}\n\nexport async function addGroup(\n  connection: OcsConnection,\n  groupId: string\n): Promise<boolean> {\n  let groupAdded: Promise<boolean>;\n\n  try {\n    groupAdded = await promisifiedAddGroup.call(connection, groupId);\n  } catch (error) {\n    groupAdded = rejectWithOcsError(error, {\n      message: 'Unable to add group',\n      identifier: groupId,\n      useMeta: true,\n      expectedErrorCodes: [400],\n      customErrors: {\n        [102]: 'group already exists',\n        [103]: 'failed to add the group'\n      }\n    });\n  }\n\n  return groupAdded;\n}\n\nexport async function deleteGroup(\n  connection: OcsConnection,\n  groupId: string\n): Promise<boolean> {\n  let groupDeleted: Promise<boolean>;\n\n  try {\n    groupDeleted = await promisifiedDeleteGroup.call(connection, groupId);\n  } catch (error) {\n    groupDeleted = rejectWithOcsError(error, {\n      message: 'Unable to delete group',\n      identifier: groupId,\n      useMeta: true,\n      expectedErrorCodes: [400],\n      customErrors: {\n        [101]: 'group does not exist',\n        [102]: 'failed to delete group'\n      }\n    });\n  }\n\n  return groupDeleted;\n}\n\nexport async function getGroupUsers(\n  connection: OcsConnection,\n  groupId: string\n): Promise<string[]> {\n  let users: Promise<string[]>;\n\n  try {\n    users = await promisifiedGetGroupUsers.call(connection, groupId);\n  } catch (error) {\n    users = rejectWithOcsError(error, {\n      message: 'Unable to list users for group',\n      identifier: groupId,\n      useMeta: false,\n      expectedErrorCodes: [404],\n      customErrors: {\n        [404]: 'the group could not be found'\n      }\n    });\n  }\n\n  return users;\n}\n\nexport async function getGroupSubAdmins(\n  connection: OcsConnection,\n  groupId: string\n): Promise<string[]> {\n  let subAdmins: Promise<string[]>;\n\n  try {\n    subAdmins = await promisifiedGetGroupSubAdmins.call(connection, groupId);\n  } catch (error) {\n    subAdmins = rejectWithOcsError(error, {\n      message: 'Unable to list sub-admins for group',\n      identifier: groupId,\n      useMeta: true,\n      expectedErrorCodes: [400],\n      customErrors: {\n        [101]: 'group does not exist'\n      }\n    });\n  }\n\n  return subAdmins;\n}\n\nexport async function getShares(\n  connection: OcsConnection,\n  path?: string,\n  includeReshares?: boolean,\n  showForSubFiles?: boolean\n): Promise<OcsShare[]> {\n  let shares: Promise<OcsShare[]>;\n\n  try {\n    shares = await promisifiedGetShares.call(connection,\n      path || '',\n      (includeReshares !== undefined ? includeReshares : false),\n      (showForSubFiles !== undefined ? showForSubFiles : false)\n    );\n  } catch (error) {\n    shares = rejectWithOcsError(error, {\n      message: 'Unable to get shares for',\n      identifier: path,\n      useMeta: true,\n      expectedErrorCodes: [400, 404],\n      customErrors: {\n        [400]: 'unable to show sub-files as this is not a directory',\n        [404]: 'file/folder doesn\\'t exist'\n      }\n    });\n  }\n\n  return shares;\n}\n\nexport async function getShare(\n  connection: OcsConnection,\n  shareId: number | string\n): Promise<OcsShare> {\n  let share: Promise<OcsShare>;\n\n  try {\n    share = await promisifiedGetShare.call(connection, shareId);\n  } catch (error) {\n    share = rejectWithOcsError(error, {\n      message: 'Unable to get share',\n      identifier: shareId,\n      useMeta: true,\n      expectedErrorCodes: [404]\n    });\n  }\n\n  return share;\n}\n\nexport async function deleteShare(\n  connection: OcsConnection,\n  shareId: number | string\n): Promise<boolean> {\n  let shareDeleted: Promise<boolean>;\n\n  try {\n    shareDeleted = await promisifiedDeleteShare.call(connection, shareId);\n  } catch (error) {\n    shareDeleted = rejectWithOcsError(error, {\n      message: 'Unable to delete share',\n      identifier: shareId,\n      useMeta: true,\n      expectedErrorCodes: [404],\n      customErrors: {\n        [404]: 'invalid shareId or the share doesn\\'t exist'\n      }\n    });\n  }\n\n  return shareDeleted;\n}\n\nexport async function addShare(\n  connection: OcsConnection,\n  path: string,\n  shareType: OcsShareType,\n  shareWith?: string,\n  permissions?: OcsSharePermissions,\n  password?: string,\n  publicUpload?: boolean,\n): Promise<OcsShare> {\n  let addedShare: Promise<OcsShare>;\n\n  try {\n    addedShare = await promisifiedAddShare.call(connection,\n      path,\n      shareType,\n      shareWith || '',\n      (permissions !== undefined ? permissions : OcsSharePermissions.default),\n      password || '',\n      (publicUpload !== undefined ? publicUpload : false),\n    );\n  } catch (error) {\n    addedShare = rejectWithOcsError(error, {\n      message: 'Unable to add share',\n      identifier: path,\n      useMeta: true,\n      expectedErrorCodes: [403, 404]\n    });\n  }\n\n  return addedShare;\n}\n\nexport function editShare(\n  connection: OcsConnection,\n  shareId: number | string\n) {\n  return {\n    async permissions(permissions: OcsSharePermissions): Promise<OcsShare> {\n      return await setFieldValue(connection, shareId, 'permissions', permissions);\n    },\n\n    async password(password: string): Promise<OcsShare> {\n      return await setFieldValue(connection, shareId, 'password', password);\n    },\n\n    async publicUpload(isPublicUpload: boolean): Promise<OcsShare> {\n      return await setFieldValue(connection, shareId, 'publicUpload', isPublicUpload);\n    },\n\n    async expireDate(expireDate: string): Promise<OcsShare> {\n      return await setFieldValue(connection, shareId, 'expireDate', expireDate);\n    },\n\n    async note(note: string): Promise<OcsShare> {\n      return await setFieldValue(connection, shareId, 'note', note);\n    }\n  };\n\n  async function setFieldValue(\n    connection: OcsConnection,\n    shareId: number | string,\n    field: OcsEditShareField,\n    value: any\n  ): Promise<OcsShare> {\n    let editedShare: Promise<OcsShare>;\n\n    try {\n      editedShare = await promisifiedEditShare.call(connection, shareId, field, String(value));\n    } catch (error) {\n      editedShare = rejectWithOcsError(error, {\n        message: `Unable to edit '${field}' of share`,\n        identifier: shareId,\n        useMeta: true,\n        expectedErrorCodes: [400, 404]\n      });\n    }\n\n    return editedShare;\n  }\n}\n\nexport async function getGroupfolders(\n  connection: OcsConnection,\n): Promise<OcsGroupfolder[]> {\n  let groupfolders: Promise<OcsGroupfolder[]>;\n\n  try {\n    groupfolders = await promisifiedGetGroupfolders.call(connection);\n  } catch (error) {\n    groupfolders = rejectWithOcsError(error, {\n      message: 'Unable to list groupfolders',\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolders;\n}\n\nexport async function getGroupfolder(\n  connection: OcsConnection,\n  groupfolderId: number,\n): Promise<OcsGroupfolder> {\n  let groupfolder: Promise<OcsGroupfolder>;\n\n  try {\n    groupfolder = await promisifiedGetGroupfolder.call(connection, groupfolderId);\n  } catch (error) {\n    groupfolder = rejectWithOcsError(error, {\n      message: 'Unable to get groupfolder',\n      identifier: groupfolderId,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolder;\n}\n\nexport async function addGroupfolder(\n  connection: OcsConnection,\n  mountpoint: string,\n): Promise<number> {\n  let addedGroupfolderId: Promise<number>;\n\n  try {\n    addedGroupfolderId = await promisifiedAddGroupfolder.call(connection, mountpoint);\n  } catch (error) {\n    addedGroupfolderId = rejectWithOcsError(error, {\n      message: 'Unable to create groupfolder',\n      identifier: mountpoint,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return addedGroupfolderId;\n}\n\nexport async function removeGroupfolder(\n  connection: OcsConnection,\n  groupfolderId: number,\n): Promise<boolean> {\n  let groupfolderDeleted: Promise<boolean>;\n\n  try {\n    groupfolderDeleted = await promisifiedRemoveGroupfolder.call(connection, groupfolderId);\n  } catch (error) {\n    groupfolderDeleted = rejectWithOcsError(error, {\n      message: 'Unable to delete groupfolder',\n      identifier: groupfolderId,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolderDeleted;\n}\n\nexport async function addGroupfolderGroup(\n  connection: OcsConnection,\n  groupfolderId: number,\n  groupId: string,\n): Promise<boolean> {\n  let groupfolderGroupAdded: Promise<boolean>;\n\n  try {\n    groupfolderGroupAdded = await promisifiedAddGroupfolderGroup.call(connection, groupfolderId, groupId);\n  } catch (error) {\n    groupfolderGroupAdded = rejectWithOcsError(error, {\n      message: 'Unable to add group to groupfolder',\n      identifier: groupfolderId,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolderGroupAdded;\n}\n\nexport async function removeGroupfolderGroup(\n  connection: OcsConnection,\n  groupfolderId: number,\n  groupId: string,\n): Promise<boolean> {\n  let groupfolderGroupRemoved: Promise<boolean>;\n\n  try {\n    groupfolderGroupRemoved = await promisifiedRemoveGroupfolderGroup.call(connection, groupfolderId, groupId);\n  } catch (error) {\n    groupfolderGroupRemoved = rejectWithOcsError(error, {\n      message: 'Unable to remove group from groupfolder',\n      identifier: groupfolderId,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolderGroupRemoved;\n}\n\nexport async function setGroupfolderPermissions(\n  connection: OcsConnection,\n  groupfolderId: number,\n  groupId: string,\n  permissions: number,\n): Promise<boolean> {\n  let groupfolderPermissionsSet: Promise<boolean>;\n\n  try {\n    groupfolderPermissionsSet = await promisifiedSetGroupfolderPermissions.call(connection, groupfolderId, groupId, permissions);\n  } catch (error) {\n    groupfolderPermissionsSet = rejectWithOcsError(error, {\n      message: 'Unable to set groupfolder permissions',\n      identifier: groupfolderId,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolderPermissionsSet;\n}\n\nexport async function enableGroupfolderACL(\n  connection: OcsConnection,\n  groupfolderId: number,\n  enable: boolean,\n): Promise<boolean> {\n  let groupfolderACLEnabled: Promise<boolean>;\n\n  try {\n    groupfolderACLEnabled = await promisifiedEnableOrDisableGroupfolderACL.call(connection, groupfolderId, enable);\n  } catch (error) {\n    groupfolderACLEnabled = rejectWithOcsError(error, {\n      message: 'Unable to enable ACL for groupfolder',\n      identifier: groupfolderId,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolderACLEnabled;\n}\n\nexport async function setGroupfolderManageACL(\n  connection: OcsConnection,\n  groupfolderId: number,\n  type: 'group' | 'user',\n  id: string,\n  manageACL: boolean,\n): Promise<boolean> {\n  let groupfolderManageACLSet: Promise<boolean>;\n\n  try {\n    groupfolderManageACLSet = await promisifiedSetGroupfolderManageACL.call(connection, groupfolderId, type, id, manageACL);\n  } catch (error) {\n    groupfolderManageACLSet = rejectWithOcsError(error, {\n      message: 'Unable to set groupfolder manage ACL settings',\n      identifier: groupfolderId,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolderManageACLSet;\n}\n\nexport async function setGroupfolderQuota(\n  connection: OcsConnection,\n  groupfolderId: number,\n  quota: number,\n): Promise<boolean> {\n  let groupfolderQuotaSet: Promise<boolean>;\n\n  try {\n    groupfolderQuotaSet = await promisifiedSetGroupfolderQuota.call(connection, groupfolderId, quota);\n  } catch (error) {\n    groupfolderQuotaSet = rejectWithOcsError(error, {\n      message: 'Unable to set groupfolder quota',\n      identifier: groupfolderId,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolderQuotaSet;\n}\n\nexport async function renameGroupfolder(\n  connection: OcsConnection,\n  groupfolderId: number,\n  mountpoint: string,\n): Promise<boolean> {\n  let groupfolderRenamed: Promise<boolean>;\n\n  try {\n    groupfolderRenamed = await promisifiedRenameGroupfolder.call(connection, groupfolderId, mountpoint);\n  } catch (error) {\n    groupfolderRenamed = rejectWithOcsError(error, {\n      message: 'Unable to rename groupfolder',\n      identifier: groupfolderId,\n      useMeta: true,\n      expectedErrorCodes: [500],\n    });\n  }\n\n  return groupfolderRenamed;\n}\n","import { OcsConnection } from './ocs-connection';\nimport { OcsActivity } from './types';\nimport { req } from '../requestWrapper';\n\nconst baseUrl = 'ocs/v2.php/apps/activity/api/v2/activity';\n\nexport function ocsGetActivities(\n  fileId: number,\n  sort: 'asc' | 'desc',\n  limit: number,\n  sinceActivityId: number,\n  callback: (error: { code, message }, activities?: OcsActivity[]) => void\n) : void {\n  const self: OcsConnection = this;\n\n  const params = {\n    format: 'json',\n    object_type: 'files',\n    object_id: fileId,\n    sort: (sort === 'asc' ? 'asc' : 'desc')\n  };\n\n  if (limit > 0) {\n    params['limit'] = limit;\n  }\n\n  if (sinceActivityId > 0) {\n    params['since'] = sinceActivityId;\n  }\n\n  const urlParams =  new URLSearchParams(params as any)\n    .toString()\n\n  req({\n      url: `${self.options.url}/${baseUrl}/filter?${urlParams}`,\n      headers: self.getHeader()\n    }, (error, response, body) => {\n      self.request(error, response, body, (error: { code, message }, body?) => {\n        let activities: OcsActivity[] = [];\n\n        if (!error && body && body.data && body.data.length > 0) {\n          body.data.forEach(activity => {\n            activities.push({\n              activityId: parseInt(activity.activity_id, 10),\n              app: activity.app,\n              type: activity.type,\n              user: activity.user,\n              subject: activity.subject,\n              subjectRich: activity.subject_rich,\n              message: activity.message,\n              messageRich: activity.message_rich,\n              objectType: activity.object_type,\n              fileId: activity.objectId,\n              objectName: activity.object_name,\n              objects: activity.objects,\n              link: activity.link,\n              icon: activity.icon,\n              datetime: activity.datetime\n            });\n          });\n        }\n\n        callback(error, activities);\n      });\n    });\n}\n","import { OcsConnection }        from './ocs/ocs-connection';\nimport { WebDavClient }         from './webdav';\n\nimport {\n  OcsShareType,\n  OcsSharePermissions,\n  type OcsEditUserField,\n  type OcsGroupfolder,\n  type OcsActivity,\n  type OcsNewUser,\n  type OcsShare,\n  type OcsUser,\n} from './ocs/types';\nimport { Optional } from 'lonad';\n\nexport * from './ocs/types';\n\nexport type AsyncFunction       = (...parameters: any[]) => Promise<any>;\nexport class NextcloudClientProperties {\n  webdavConnection: Optional<WebDavClient>;\n  ocsConnection:    OcsConnection;\n  username:         string;\n  url:              string;\n}\n\nexport interface NextcloudClientInterface extends NextcloudClientProperties {\n  as(username: string, password: string): NextcloudClientInterface;\n  get:                                                                        WebDavClient['get'];\n  put:                                                                        WebDavClient['put'];\n  move:                                                                       WebDavClient['move'];\n  remove:                                                                     WebDavClient['remove'];\n  exists:                                                                     WebDavClient['exists'];\n  rename:                                                                     WebDavClient['rename'];\n  getFiles:                                                                   WebDavClient['getFiles'];\n  getPathInfo:                                                                WebDavClient['getPathInfo'];\n  touchFolder:                                                                WebDavClient['touchFolder'];\n  getReadStream:                                                              WebDavClient['getReadStream'];\n  getWriteStream:                                                             WebDavClient['getWriteStream'];\n  uploadFromStream:                                                           WebDavClient['uploadFromStream'];\n  downloadToStream:                                                           WebDavClient['downloadToStream'];\n  checkConnectivity:                                                          WebDavClient['checkConnectivity'];\n  getFolderProperties:                                                        WebDavClient['getFolderProperties'];\n  getFolderFileDetails:                                                       WebDavClient['getFolderFileDetails'];\n  createFolderHierarchy:                                                      WebDavClient['createFolderHierarchy'];\n\n\n  // Common\n  getCreatorByFileId(fileId: number | string):                                Promise<string>;\n  getCreatorByPath(path: string):                                             Promise<string>;\n\n  // OCS\n  activities: {\n    get: (fileId: number | string, sort?: 'asc' | 'desc',\n    limit?: number, sinceActivityId?: number) =>                              Promise<OcsActivity[]>\n  };\n  users: {\n    removeSubAdminFromGroup: (userId: string, groupId: string) =>             Promise<boolean>\n    addSubAdminToGroup: (userId: string, groupId: string) =>                  Promise<boolean>\n    resendWelcomeEmail: (userId: string) =>                                   Promise<boolean>\n    getSubAdminGroups: (userId: string) =>                                    Promise<string[]>\n    removeFromGroup: (userId: string, groupId: string) =>                     Promise<boolean>\n    setEnabled: (userId: string, isEnabled: boolean) =>                       Promise<boolean>\n    addToGroup: (userId: string, groupId: string) =>                          Promise<boolean>\n    getGroups: (userId: string) =>                                            Promise<string[]>\n    delete: (userId: string) =>                                               Promise<boolean>\n    edit: (userId: string, field: OcsEditUserField, value: string) =>         Promise<boolean>\n    list: (search?: string, limit?: number, offset?: number) =>               Promise<string[]>\n    add: (user: OcsNewUser) =>                                                Promise<boolean>\n    get: (userId: string) =>                                                  Promise<OcsUser>\n  };\n\n  groups: {\n    getSubAdmins: (groupId: string) =>                                        Promise<string[]>\n    getUsers: (groupId: string) =>                                            Promise<string[]>\n    delete: (groupId: string) =>                                              Promise<boolean>\n    list: (search?: string, limit?: number, offset?: number) =>               Promise<string[]>\n    add: (groupId: string) =>                                                 Promise<boolean>\n  };\n\n  shares: {\n    delete: (shareId: string | number) =>                                     Promise<boolean>\n    edit: {\n      permissions: (shareId: string | number,\n      permissions: OcsSharePermissions) =>                                    Promise<OcsShare>\n      password: (shareId: string | number,\n      password: string) =>                                                    Promise<OcsShare>\n      publicUpload: (shareId: string | number,\n      isPublicUpload: boolean) =>                                             Promise<OcsShare>\n      expireDate: (shareId: string | number,\n      expireDate: string) =>                                                  Promise<OcsShare>\n      note: (shareId: string | number, note: string) =>                       Promise<OcsShare>\n    }\n    list: (path?: string, includeReshares?: boolean,\n    showForSubFiles?: boolean) =>                                             Promise<OcsShare[]>\n    add: (path: string, shareType: OcsShareType, shareWith?: string,\n      permissions?: OcsSharePermissions, password?: string,\n      publicUpload?: boolean) =>                                              Promise<OcsShare>\n    get: (shareId: string | number) =>                                        Promise<OcsShare>\n  };\n\n  groupfolders: {\n    getFolders: () => Promise<OcsGroupfolder[]>\n    getFolder: (fid: number) => Promise<OcsGroupfolder>\n    addFolder: (mountpoint: string) => Promise<number>\n    removeFolder: (fid: number) => Promise<boolean>\n    addGroup: (fid: number, gid: string) => Promise<boolean>\n    removeGroup: (fid: number, gid: string) => Promise<boolean>\n    setPermissions: (fid: number, gid: string, permissions: number) => Promise<boolean>\n    enableACL: (fid: number, enable: boolean) => Promise<boolean>\n    setManageACL: (fid: number, type: 'group' | 'user', id: string, manageACL: boolean) => Promise<boolean>\n    setQuota: (fid: number, quota: number) => Promise<boolean>\n    renameFolder: (fid: number, mountpoint: string) => Promise<boolean>\n  };\n}\n\nexport interface ConnectionOptions {\n  url:       string;\n  username?: string;\n  password?: string;\n}\n","import { createDetailProperty } from './webdav.utils';\n\n/**\n * Creates a ownCloud detail property for use with the various WebDAV methods.\n * @param element The element name (e.g. `fileid`)\n * @param nativeType **UNUSED** - The native type of the property (e.g. `number`)\n * @param defaultValue The default value to return if the property is not found\n * @returns A detail property\n *\n * @deprecated Use `createDetailProperty` instead\n */\nexport function createOwnCloudFileDetailProperty(element: string, nativeType?: boolean, defaultValue?: any) {\n  return createDetailProperty('oc', element, defaultValue);\n}\n\n/**\n * Creates a NextCloud detail property for use with the various WebDAV methods.\n * @param element The element name (e.g. `fileid`)\n * @param nativeType **UNUSED** - The native type of the property (e.g. `number`)\n * @param defaultValue The default value to return if the property is not found\n * @returns A detail property\n *\n * @deprecated Use `createDetailProperty` instead\n */\nexport function createNextCloudFileDetailProperty(element: string, nativeType?: boolean, defaultValue?: any) {\n  return createDetailProperty('nc', element, defaultValue);\n}\n","import {\n  WebDavClient\n} from './webdav';\n\nimport {\n  getCreatorByFileId,\n  getCreatorByPath,\n} from './common';\n\nexport * from './errors';\n\nimport {\n  addRemoveUserSubAdminForGroup,\n  setGroupfolderPermissions,\n  setGroupfolderManageACL,\n  configureOcsConnection,\n  resendUserWelcomeEmail,\n  removeGroupfolderGroup,\n  addRemoveUserForGroup,\n  enableGroupfolderACL,\n  addGroupfolderGroup,\n  setGroupfolderQuota,\n  getGroupSubAdmins,\n  renameGroupfolder,\n  removeGroupfolder,\n  getUserSubAdmins,\n  getGroupfolders,\n  addGroupfolder,\n  getGroupfolder,\n  setUserEnabled,\n  getActivities,\n  getGroupUsers,\n  getUserGroups,\n  deleteGroup,\n  deleteShare,\n  deleteUser,\n  listGroups,\n  editShare,\n  getShares,\n  listUsers,\n  addGroup,\n  addShare,\n  editUser,\n  getShare,\n  getUser,\n  addUser,\n} from './ocs/ocs';\n\nimport {\n  OcsShareType,\n  OcsSharePermissions,\n  type OcsEditUserField,\n  type OcsNewUser,\n  type OcsUser,\n} from './ocs/types';\n\nimport {\n  NextcloudClientProperties,\n  type NextcloudClientInterface,\n  type ConnectionOptions\n} from './types';\nimport OcsConnection from './ocs/ocs-connection';\nimport { NextCloudClientException } from './errors';\nimport { Optional } from 'lonad';\n\nexport {\n  createOwnCloudFileDetailProperty,\n  createNextCloudFileDetailProperty,\n} from './helper';\n\nexport { createDetailProperty } from './webdav.utils';\n\nexport class NextcloudClient extends NextcloudClientProperties implements NextcloudClientInterface {\n  configureOcsConnection    = configureOcsConnection;\n\n  createFolderHierarchy     = this.wrapWebDav(WebDavClient.prototype.createFolderHierarchy);\n  getFolderFileDetails      = this.wrapWebDav(WebDavClient.prototype.getFolderFileDetails);\n  getFolderProperties       = this.wrapWebDav(WebDavClient.prototype.getFolderProperties);\n  checkConnectivity         = this.wrapWebDav(WebDavClient.prototype.checkConnectivity);\n  downloadToStream          = this.wrapWebDav(WebDavClient.prototype.downloadToStream);\n  uploadFromStream          = this.wrapWebDav(WebDavClient.prototype.uploadFromStream);\n  getFilesDetailed          = this.wrapWebDav(WebDavClient.prototype.getFilesDetailed);\n  getWriteStream            = this.wrapWebDav(WebDavClient.prototype.getWriteStream);\n  getReadStream             = this.wrapWebDav(WebDavClient.prototype.getReadStream);\n  touchFolder               = this.wrapWebDav(WebDavClient.prototype.touchFolder);\n  getPathInfo               = this.wrapWebDav(WebDavClient.prototype.getPathInfo);\n  getFiles                  = this.wrapWebDav(WebDavClient.prototype.getFiles);\n  rename                    = this.wrapWebDav(WebDavClient.prototype.rename);\n  remove                    = this.wrapWebDav(WebDavClient.prototype.remove);\n  exists                    = this.wrapWebDav(WebDavClient.prototype.exists);\n  move                      = this.wrapWebDav(WebDavClient.prototype.move);\n  put                       = this.wrapWebDav(WebDavClient.prototype.put);\n  get                       = this.wrapWebDav(WebDavClient.prototype.get);\n\n  // Common\n  getCreatorByFileId          = getCreatorByFileId;\n  getCreatorByPath            = getCreatorByPath;\n\n  // OCS\n  activities = {\n    get                     : (\n      fileId: number | string,\n      sort?: 'asc' | 'desc',\n      limit?: number,\n      sinceActivityId?: number\n    ) => getActivities(this.ocsConnection, fileId, sort, limit, sinceActivityId)\n  };\n\n  users = {\n    removeSubAdminFromGroup : (userId: string, groupId: string) => addRemoveUserSubAdminForGroup(this.ocsConnection, userId, groupId, false),\n    addSubAdminToGroup      : (userId: string, groupId: string) => addRemoveUserSubAdminForGroup(this.ocsConnection, userId, groupId, true),\n    resendWelcomeEmail      : (userId: string) => resendUserWelcomeEmail(this.ocsConnection, userId),\n    getSubAdminGroups       : (userId: string) => getUserSubAdmins(this.ocsConnection, userId),\n    removeFromGroup         : (userId: string, groupId: string) => addRemoveUserForGroup(this.ocsConnection, userId, groupId, false),\n    setEnabled              : (userId: string, isEnabled: boolean) => setUserEnabled(this.ocsConnection, userId, isEnabled),\n    addToGroup              : (userId: string, groupId: string) => addRemoveUserForGroup(this.ocsConnection, userId, groupId, true),\n    getGroups               : (userId: string) => getUserGroups(this.ocsConnection, userId),\n    delete                  : (userId: string) => deleteUser(this.ocsConnection, userId),\n    edit                    : (userId: string, field: OcsEditUserField, value: string) => editUser(this.ocsConnection, userId, field, value),\n    list                    : (search?: string, limit?: number, offset?: number) => listUsers(this.ocsConnection, search, limit, offset),\n    add                     : (user: OcsNewUser) => addUser(this.ocsConnection, user),\n    get                     : (userId: string) => getUser(this.ocsConnection, userId),\n  };\n\n  groups = {\n    getSubAdmins            : (groupId: string) => getGroupSubAdmins(this.ocsConnection, groupId),\n    getUsers                : (groupId: string) => getGroupUsers(this.ocsConnection, groupId),\n    delete                  : (groupId: string) => deleteGroup(this.ocsConnection, groupId),\n    list                    : (search?: string, limit?: number, offset?: number) => listGroups(this.ocsConnection, search, limit, offset),\n    add                     : (groupId: string) => addGroup(this.ocsConnection, groupId),\n  };\n\n  shares = {\n    delete                  : (shareId: number | string) => deleteShare(this.ocsConnection, shareId),\n    edit: {\n      permissions           : (shareId: number | string, permissions: OcsSharePermissions) => editShare(this.ocsConnection, shareId).permissions(permissions),\n      password              : (shareId: number | string, password: string) => editShare(this.ocsConnection, shareId).password(password),\n      publicUpload          : (shareId: number | string, isPublicUpload: boolean) => editShare(this.ocsConnection, shareId).publicUpload(isPublicUpload),\n      expireDate            : (shareId: number | string, expireDate: string) => editShare(this.ocsConnection, shareId).expireDate(expireDate),\n      note                  : (shareId: number | string, note: string) => editShare(this.ocsConnection, shareId).note(note),\n    },\n    list                    : (path?: string, includeReshares?: boolean, showForSubFiles?: boolean) => getShares(this.ocsConnection, path, includeReshares, showForSubFiles),\n    add                     : (path: string, shareType: OcsShareType, shareWith?: string, permissions?: OcsSharePermissions,\n    password?: string, publicUpload?: boolean) => addShare(this.ocsConnection, path, shareType, shareWith, permissions, password, publicUpload),\n    get                     : (shareId: number | string) => getShare(this.ocsConnection, shareId),\n  };\n\n  groupfolders = {\n    getFolders: () => getGroupfolders(this.ocsConnection),\n    getFolder: (fid: number) => getGroupfolder(this.ocsConnection, fid),\n    addFolder: (mountpoint: string) => addGroupfolder(this.ocsConnection, mountpoint),\n    removeFolder: (fid: number) => removeGroupfolder(this.ocsConnection, fid),\n    addGroup: (fid: number, gid: string) => addGroupfolderGroup(this.ocsConnection, fid, gid),\n    removeGroup: (fid: number, gid: string) => removeGroupfolderGroup(this.ocsConnection, fid, gid),\n    setPermissions: (fid: number, gid: string, permissions: number) => setGroupfolderPermissions(this.ocsConnection, fid, gid, permissions),\n    enableACL: (fid: number, enable: boolean) => enableGroupfolderACL(this.ocsConnection, fid, enable),\n    setManageACL: (fid: number, type: 'group' | 'user', id: string, manageACL: boolean) => setGroupfolderManageACL(this.ocsConnection, fid, type, id, manageACL),\n    setQuota: (fid: number, quota: number) => setGroupfolderQuota(this.ocsConnection, fid, quota),\n    renameFolder: (fid: number, mountpoint: string) => renameGroupfolder(this.ocsConnection, fid, mountpoint),\n  };\n\n  constructor(private options: ConnectionOptions) {\n    super();\n\n    this.username = options.username;\n    this.url      = options.url.endsWith('/') ? options.url.slice(0, -1) : options.url;\n\n    this.webdavConnection = Optional.None();\n\n    this.configureOcsConnection(options);\n  }\n\n  as(username: string, password: string): NextcloudClient {\n    return new NextcloudClient({ username, password, url: this.url });\n  }\n\n  /**\n   * Wrap a given prototype function to ensure such that the function called is\n   * using the initialized WebDAV connection.\n   * @param fn The function to wrap\n   * @returns The wrapped function\n   */\n  private wrapWebDav<TFn extends (...args: any[]) => any>(fn: TFn): ReturnType<TFn> extends PromiseLike<any>\n    ? TFn\n    : Promise<ReturnType<TFn>> {\n    return (async (...args: any[]) => {\n      if (Optional.isNone(this.webdavConnection)) {\n        this.webdavConnection = Optional.fromNullable(\n          await WebDavClient.create(this.url, this.options)\n        );\n      }\n\n      if (Optional.isNone(this.webdavConnection)) {\n        throw new NextCloudClientException('WebDAV connection could not be initialized');\n      }\n\n      return fn.apply(this.webdavConnection.get(), args);\n    }) as any;\n  }\n}\n\n// Shush, Typescript…\nexport default NextcloudClient;\n"],"names":["createErrorType","initialize","ErrorClass","prototype","Error","Constructor","data","error","Object","create","stack","assign","NextCloudException","message","subError","NextCloudServerException","NextCloudClientException","ForbiddenError","path","NotFoundError","NotReadyError","UnreachableError","IncorrectPathTypeError","options","type","ConflictError","OcsError","identifier","reason","statusCode","id","name","BadArgumentError","WRAPPED_FUNCTIONS","wrapError","response","status","isWebDavError","isNotFoundError","isForbiddenError","isConflictError","SHORT_CODE_TO_NAMESPACE","short","full","elements","reduce","acc","namespace","createDetailProperty","element","defaultValue","namespaceShort","default","defaultProperties","WebDavClient","constructor","static","url","thisClient","root","username","client","loadClient","async","webDav","Function","createClient","urlNoTrailingSlash","trimEnd","replace","pathNoLeadingSlash","trimStart","nextcloudRoot","this","forEach","fnName","pathPosition","originalFn","args","apply","undefined","getPath","Result","fromPromise","getDirectoryContents","map","Boolean","getOrElse","exists","recover","toPromise","recursive","reject","expectMap","createDirectory","newName","basePath","Optional","fromNullable","slice","lastIndexOf","newPath","flatMap","expect","abortOnErrorWith","move","destination","moveFile","deleteFile","content","putFileContents","getFileContents","touchFolder","formattedOptions","formatOptions","result","isDetailedResult","file","props","setDefaults","properties","getFilesDetailed","details","files","basename","extraProperties","isFile","isDirectory","lastModified","lastmod","href","stat","res","getPathInfo","curr","readStream","Stream.PassThrough","get","remoteReadStream","createReadStream","pipe","on","err","emit","writeStream","overwrite","otherOptions","put","then","onFinished","catch","Promise","resolve","getWriteStream","pipeStreams","getReadStream","concat","filter","length","namespaces","Set","detail","join","fileDetailsToXMLString","hasOwnProperty","fail","getCreatorByPath","self","fileId","fileid","getCreatorByFileId","activities","find","activity","user","OcsShareType","OcsSharePermissions","rejectWithOcsError","errorInfo","expectedErrorCodes","includes","code","useMeta","meta","statuscode","customErrors","ocsSharePermissionsToText","permissions","all","keys","key","push","promisify","fn","call","req","callback","axios","method","validateStatus","OcsConnection","String","substring","getHeader","withBody","Accept","Authorization","Buffer","from","password","toString","isValidResponse","body","ocs","request","jsonBody","JSON","parse","statusText","baseUrl","parseOcsShare","share","timestamp","parseInt","stime","permissionsInt","shareTypeInt","share_type","obj","shareType","shareTypeSystemName","ownerUserId","uid_owner","ownerDisplayName","displayname_owner","permissionsText","sharedOn","Date","sharedOnTimestamp","parent","expiration","token","fileOwnerUserId","uid_file_owner","fileOwnerDisplayName","displayname_file_owner","note","label","itemType","item_type","mimeType","mimetype","storageId","storage_id","storage","item_source","parentFileId","file_parent","fileTarget","file_target","sharedWith","share_with","sharedWithDisplayName","share_with_displayname","mailSend","mail_send","hideDownload","hide_download","target","sources","source","val","assignDefined","sendPasswordByTalk","send_password_by_talk","parseOcsGroupfolder","groupfolder","mountPoint","mount_point","groups","quota","size","acl","manage","promisifiedGetActivities","sort","limit","sinceActivityId","params","format","object_type","object_id","urlParams","URLSearchParams","headers","activityId","activity_id","app","subject","subjectRich","subject_rich","messageRich","message_rich","objectType","objectId","objectName","object_name","objects","link","icon","datetime","promisifiedResendUserWelcomeEmail","userId","success","promisifiedAddRemoveUserForGroup","groupId","toAdd","stringify","groupid","userModifiedForGroup","promisifiedGetUserSubAdmins","subAdmins","subAdmin","promisifiedSetUserSubAdmin","isSubAdmin","subAdminModifiedForGroup","promisifiedSetUserEnabled","isEnabled","promisifiedGetUserGroups","group","promisifiedDeleteUser","userDeleted","promisifiedListUsers","search","offset","users","promisifiedEditUser","field","value","userEdited","promisifiedAddUser","userid","userAdded","promisifiedGetUser","enabled","lastLogin","email","displayname","phone","address","website","twitter","language","locale","promisifiedGetGroupSubAdmins","promisifiedGetGroupUsers","promisifiedDeleteGroup","groupDeleted","promisifiedListGroups","promisifiedAddGroup","groupAdded","promisifiedDeleteShare","shareId","shareDeleted","promisifiedEditShare","promisifiedGetShares","includeReshares","showForSubFiles","promisifiedGetShare","promisifiedAddShare","shareWith","publicUpload","promisifiedGetGroupfolders","values","promisifiedGetGroupfolder","groupfolderId","promisifiedAddGroupfolder","mountpoint","promisifiedRemoveGroupfolder","groupfolderDeleted","promisifiedAddGroupfolderGroup","groupfolderGroupAdded","promisifiedRemoveGroupfolderGroup","groupfolderGroupRemoved","promisifiedEnableOrDisableGroupfolderACL","enable","groupfolderACLset","promisifiedRenameGroupfolder","groupfolderRenamed","promisifiedSetGroupfolderQuota","Number","isNaN","groupfolderQuotaSet","promisifiedSetGroupfolderPermissions","groupfolderPermissionsSet","promisifiedSetGroupfolderManageACL","manageACL","mappingType","mappingId","manageAcl","configureOcsConnection","ocsConnection","addRemoveUserForGroup","connection","addRemoveUserSubAdminForGroup","editShare","setFieldValue","isPublicUpload","expireDate","editedShare","NextcloudClientProperties","createOwnCloudFileDetailProperty","nativeType","createNextCloudFileDetailProperty","NextcloudClient","super","createFolderHierarchy","wrapWebDav","getFolderFileDetails","getFolderProperties","checkConnectivity","downloadToStream","uploadFromStream","getFiles","rename","remove","getActivities","removeSubAdminFromGroup","addSubAdminToGroup","resendWelcomeEmail","resendUserWelcomeEmail","getSubAdminGroups","getUserSubAdmins","removeFromGroup","setEnabled","setUserEnabled","addToGroup","getGroups","getUserGroups","delete","deleteUser","edit","editUser","list","isInteger","listUsers","add","addUser","getUser","getSubAdmins","getGroupSubAdmins","getUsers","getGroupUsers","deleteGroup","listGroups","addGroup","shares","deleteShare","getShares","addedShare","addShare","getShare","groupfolders","getFolders","getGroupfolders","getFolder","fid","getGroupfolder","addFolder","addedGroupfolderId","addGroupfolder","removeFolder","removeGroupfolder","gid","addGroupfolderGroup","removeGroup","removeGroupfolderGroup","setPermissions","setGroupfolderPermissions","enableACL","groupfolderACLEnabled","enableGroupfolderACL","setManageACL","groupfolderManageACLSet","setGroupfolderManageACL","setQuota","setGroupfolderQuota","renameFolder","renameGroupfolder","endsWith","webdavConnection","None","as","isNone"],"mappings":"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"}